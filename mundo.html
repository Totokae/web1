<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mundo Virtual - Aula</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #1a1a2e;
            font-family: 'Courier New', monospace;
        }

        #root {
            width: 100%;
            height: 100%;
        }

        /* Pantalla de Ingreso */
        .join-screen {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }

        .join-form {
            background: rgba(0, 0, 0, 0.8);
            padding: 40px;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            min-width: 350px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .join-form h2 {
            color: white;
            margin-bottom: 30px;
            text-align: center;
            font-size: 24px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            color: white;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .form-group input {
            width: 100%;
            padding: 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 16px;
            font-family: 'Courier New', monospace;
        }

        .form-group input:focus {
            outline: none;
            border-color: #4CAF50;
            background: rgba(255, 255, 255, 0.15);
        }

        .color-picker {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .color-option {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
        }

        .color-option:hover {
            transform: scale(1.1);
            border-color: white;
        }

        .color-option.selected {
            border-color: white;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
        }

        .join-button {
            width: 100%;
            padding: 14px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: background 0.2s;
        }

        .join-button:hover {
            background: #45a049;
        }

        .join-button:disabled {
            background: #666;
            cursor: not-allowed;
        }

        /* Game Container */
        .game-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        canvas {
            display: block;
            background: #16213e;
        }

        .ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 10;
        }

        .players-list {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 10;
            min-width: 200px;
        }

        .players-list h3 {
            margin-bottom: 8px;
            font-size: 14px;
        }

        .player-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            padding: 4px;
        }

        .player-color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            border: 1px solid white;
        }

        .controls-hint {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 5px;
            z-index: 10;
        }

        .admin-button {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 15;
            padding: 8px 16px;
            background: rgba(55, 65, 81, 0.9);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
        }

        .admin-button:hover {
            background: rgba(75, 85, 99, 0.9);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .admin-button.admin-active {
            background: rgba(34, 197, 94, 0.9);
            border-color: rgba(34, 197, 94, 1);
        }

        .interaction-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 16px;
            background: rgba(76, 175, 80, 0.9);
            padding: 12px 20px;
            border-radius: 8px;
            z-index: 20;
            pointer-events: none;
            animation: pulse 1.5s ease-in-out infinite;
            border: 2px solid white;
            font-weight: bold;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            50% {
                opacity: 0.8;
                transform: translate(-50%, -50%) scale(1.05);
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // Configuración de Supabase
        const SUPABASE_URL = 'https://qkryjldoiandvrqqxszc.supabase.co';
        const SUPABASE_ANON_KEY = 'sb_publishable_qP8lp3-rT-f_6svcadtaHQ_b_KoqnmY';

        // Inicializar Supabase
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // Colores disponibles
        const AVAILABLE_COLORS = [
            '#4CAF50', // Verde
            '#2196F3', // Azul
            '#FF9800', // Naranja
            '#F44336', // Rojo
            '#9C27B0', // Púrpura
            '#00BCD4', // Cyan
            '#FFEB3B', // Amarillo
            '#E91E63', // Rosa
            '#795548', // Marrón
            '#607D8B', // Azul gris
            '#FF5722', // Naranja oscuro
            '#3F51B5'  // Índigo
        ];

        // Hook useMultiplayer
        const useMultiplayer = (playerData) => {
            const channelRef = useRef(null);
            const [otherPlayers, setOtherPlayers] = useState({});
            const [onlineUsers, setOnlineUsers] = useState([]);
            const lastBroadcastRef = useRef(0);
            const throttleMs = 80; // Throttle de 80ms
            const broadcastPositionRef = useRef(null);

            useEffect(() => {
                if (!playerData) return;

                // Crear canal de Realtime
                const channel = supabase.channel('classroom_1', {
                    config: {
                        broadcast: { self: true },
                        presence: { key: playerData.userId }
                    }
                });

                // Suscribirse a presencia (quién está online)
                channel.on('presence', { event: 'sync' }, () => {
                    const presenceState = channel.presenceState();
                    const users = [];
                    Object.keys(presenceState).forEach(userId => {
                        const presences = presenceState[userId];
                        if (presences && presences.length > 0) {
                            const presence = presences[0];
                            users.push({
                                userId: userId,
                                nickname: presence.nickname || 'Anónimo',
                                color: presence.color || '#4CAF50'
                            });
                        }
                    });
                    setOnlineUsers(users);
                });

                // Suscribirse a broadcast (posiciones de otros jugadores)
                channel.on('broadcast', { event: 'position' }, (payload) => {
                    const { userId, x, y, color, nickname } = payload.payload;
                    if (userId !== playerData.userId) {
                        setOtherPlayers(prev => ({
                            ...prev,
                            [userId]: { x, y, color, nickname, userId }
                        }));
                    }
                });

                // Suscribirse al canal
                channel.subscribe(async (status) => {
                    if (status === 'SUBSCRIBED') {
                        // Enviar presencia inicial
                        await channel.track({
                            userId: playerData.userId,
                            nickname: playerData.nickname,
                            color: playerData.color,
                            x: playerData.x || 400,
                            y: playerData.y || 300
                        });
                    }
                });

                channelRef.current = channel;

                // Función para enviar posición con throttle
                broadcastPositionRef.current = (x, y) => {
                    const now = Date.now();
                    if (now - lastBroadcastRef.current < throttleMs) {
                        return;
                    }
                    lastBroadcastRef.current = now;

                    if (channel && playerData) {
                        channel.send({
                            type: 'broadcast',
                            event: 'position',
                            payload: {
                                userId: playerData.userId,
                                x: Math.round(x),
                                y: Math.round(y),
                                color: playerData.color,
                                nickname: playerData.nickname
                            }
                        });
                    }
                };

                return () => {
                    if (channelRef.current) {
                        channelRef.current.unsubscribe();
                        channelRef.current = null;
                    }
                    broadcastPositionRef.current = null;
                };
            }, [playerData]);

            // Retornar función wrapper que siempre verifica el ref
            const broadcastPosition = useCallback((x, y) => {
                if (broadcastPositionRef.current) {
                    broadcastPositionRef.current(x, y);
                }
            }, []);

            return { otherPlayers, onlineUsers, broadcastPosition };
        };

        // Componente JoinScreen
        const JoinScreen = ({ onJoin }) => {
            const [nickname, setNickname] = useState('');
            const [selectedColor, setSelectedColor] = useState(AVAILABLE_COLORS[0]);

            const handleSubmit = (e) => {
                e.preventDefault();
                if (nickname.trim()) {
                    const userId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                    onJoin({
                        userId,
                        nickname: nickname.trim(),
                        color: selectedColor
                    });
                }
            };

            return (
                <div className="join-screen">
                    <form className="join-form" onSubmit={handleSubmit}>
                        <h2>Unirse al Aula Virtual</h2>
                        <div className="form-group">
                            <label htmlFor="nickname">Nickname:</label>
                            <input
                                id="nickname"
                                type="text"
                                value={nickname}
                                onChange={(e) => setNickname(e.target.value)}
                                placeholder="Ingresa tu nombre"
                                maxLength={20}
                                required
                                autoFocus
                            />
                        </div>
                        <div className="form-group">
                            <label>Elige tu color:</label>
                            <div className="color-picker">
                                {AVAILABLE_COLORS.map((color) => (
                                    <div
                                        key={color}
                                        className={`color-option ${selectedColor === color ? 'selected' : ''}`}
                                        style={{ backgroundColor: color }}
                                        onClick={() => setSelectedColor(color)}
                                    />
                                ))}
                            </div>
                        </div>
                        <button
                            type="submit"
                            className="join-button"
                            disabled={!nickname.trim()}
                        >
                            Entrar al Aula
                        </button>
                    </form>
                </div>
            );
        };

        // Componente AdminLogin
        const AdminLogin = ({ isAdmin, onLoginSuccess, onLogout }) => {
            const [showLogin, setShowLogin] = useState(false);
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [error, setError] = useState('');
            const [loading, setLoading] = useState(false);

            const handleLogin = async (e) => {
                e.preventDefault();
                setError('');
                setLoading(true);

                try {
                    const { data, error: authError } = await supabase.auth.signInWithPassword({
                        email: email.trim(),
                        password: password
                    });

                    if (authError) {
                        setError(authError.message);
                    } else {
                        onLoginSuccess();
                        setShowLogin(false);
                        setEmail('');
                        setPassword('');
                    }
                } catch (err) {
                    setError('Error al iniciar sesión');
                    console.error(err);
                } finally {
                    setLoading(false);
                }
            };

            const handleLogout = async () => {
                await supabase.auth.signOut();
                onLogout();
            };

            if (isAdmin) {
                return (
                    <>
                        <button
                            className="admin-button admin-active"
                            onClick={handleLogout}
                            title="Cerrar sesión de admin"
                        >
                            Admin: Conectado
                        </button>
                    </>
                );
            }

            return (
                <>
                    <button
                        className="admin-button"
                        onClick={() => setShowLogin(!showLogin)}
                    >
                        Admin Login
                    </button>
                    {showLogin && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                            <div className="bg-white rounded-lg shadow-xl max-w-md w-full mx-4">
                                <div className="bg-gray-800 text-white px-6 py-4 flex justify-between items-center">
                                    <h2 className="text-xl font-bold">Login de Admin</h2>
                                    <button
                                        onClick={() => {
                                            setShowLogin(false);
                                            setError('');
                                        }}
                                        className="text-white hover:text-gray-300 text-2xl font-bold"
                                    >
                                        ×
                                    </button>
                                </div>
                                <form onSubmit={handleLogin} className="p-6">
                                    {error && (
                                        <div className="mb-4 p-3 bg-red-100 border border-red-400 text-red-700 rounded">
                                            {error}
                                        </div>
                                    )}
                                    <div className="mb-4">
                                        <label className="block text-gray-700 text-sm font-bold mb-2">
                                            Email:
                                        </label>
                                        <input
                                            type="email"
                                            value={email}
                                            onChange={(e) => setEmail(e.target.value)}
                                            className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:border-gray-800"
                                            required
                                            autoFocus
                                        />
                                    </div>
                                    <div className="mb-6">
                                        <label className="block text-gray-700 text-sm font-bold mb-2">
                                            Contraseña:
                                        </label>
                                        <input
                                            type="password"
                                            value={password}
                                            onChange={(e) => setPassword(e.target.value)}
                                            className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:border-gray-800"
                                            required
                                        />
                                    </div>
                                    <div className="flex justify-end gap-3">
                                        <button
                                            type="button"
                                            onClick={() => {
                                                setShowLogin(false);
                                                setError('');
                                            }}
                                            className="px-4 py-2 border border-gray-300 rounded hover:bg-gray-100 transition"
                                            disabled={loading}
                                        >
                                            Cancelar
                                        </button>
                                        <button
                                            type="submit"
                                            className="px-4 py-2 bg-gray-800 text-white rounded hover:bg-gray-700 transition"
                                            disabled={loading}
                                        >
                                            {loading ? 'Iniciando...' : 'Iniciar Sesión'}
                                        </button>
                                    </div>
                                </form>
                            </div>
                        </div>
                    )}
                </>
            );
        };

        // Componente Modal
        const ObjectModal = ({ object, onClose, isAdmin, onSave }) => {
            const [content, setContent] = useState(object?.content || '');
            const [saving, setSaving] = useState(false);

            useEffect(() => {
                if (object) {
                    setContent(object.content || '');
                }
            }, [object]);

            if (!object) return null;

            const handleSave = async () => {
                if (!isAdmin) return;
                
                setSaving(true);
                try {
                    await onSave(object.id, content);
                    onClose();
                } catch (error) {
                    console.error('Error al guardar:', error);
                    alert('Error al guardar los cambios');
                } finally {
                    setSaving(false);
                }
            };

            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                    <div className="bg-white rounded-lg shadow-xl max-w-2xl w-full mx-4 max-h-[80vh] overflow-hidden flex flex-col">
                        <div className="bg-gray-800 text-white px-6 py-4 flex justify-between items-center">
                            <h2 className="text-xl font-bold">
                                Pizarra: {object.type}
                                {isAdmin && <span className="ml-2 text-sm text-green-300">(Modo Edición)</span>}
                            </h2>
                            <button
                                onClick={onClose}
                                className="text-white hover:text-gray-300 text-2xl font-bold"
                            >
                                ×
                            </button>
                        </div>
                        <div className="p-6 overflow-y-auto flex-1">
                            {isAdmin ? (
                                <textarea
                                    value={content}
                                    onChange={(e) => setContent(e.target.value)}
                                    className="w-full h-full p-4 border border-gray-300 rounded font-mono text-sm focus:outline-none focus:border-gray-800 resize-none"
                                    placeholder="Escribe el contenido de la pizarra aquí..."
                                />
                            ) : (
                                <div className="whitespace-pre-wrap text-gray-800 font-mono">
                                    {object.content || '(Vacío)'}
                                </div>
                            )}
                        </div>
                        <div className="bg-gray-100 px-6 py-4 flex justify-between">
                            <button
                                onClick={onClose}
                                className="px-6 py-2 border border-gray-300 rounded hover:bg-gray-200 transition"
                            >
                                Cerrar
                            </button>
                            {isAdmin && (
                                <button
                                    onClick={handleSave}
                                    disabled={saving}
                                    className="px-6 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition disabled:bg-gray-400 disabled:cursor-not-allowed"
                                >
                                    {saving ? 'Guardando...' : 'Guardar Cambios'}
                                </button>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // Componente GameCanvas
        const GameCanvas = ({ playerData, interactiveObjects, isAdmin, onSaveObject }) => {
            const canvasRef = useRef(null);
            const animationFrameRef = useRef(null);
            const keysRef = useRef({});
            
            // Estado del jugador local
            const [player, setPlayer] = useState({
                x: 400,
                y: 300,
                color: playerData.color,
                nickname: playerData.nickname,
                radius: 15,
                speed: 3
            });

            // Estado para objeto cercano y modal
            const [nearbyObject, setNearbyObject] = useState(null);
            const [selectedObject, setSelectedObject] = useState(null);
            const selectedObjectRef = useRef(null);
            const interactionRadius = 50; // Radio de interacción en píxeles
            const OBJECT_WIDTH = 200;
            const OBJECT_HEIGHT = 150;

            // Actualizar objeto seleccionado cuando cambie desde Realtime
            useEffect(() => {
                if (selectedObject && interactiveObjects) {
                    const updatedObject = interactiveObjects.find(obj => obj.id === selectedObject.id);
                    if (updatedObject) {
                        setSelectedObject(updatedObject);
                        selectedObjectRef.current = updatedObject;
                    }
                }
            }, [interactiveObjects]);

            // Hook de multiplayer
            const { otherPlayers, onlineUsers, broadcastPosition } = useMultiplayer(playerData);

            // Manejo de teclado
            useEffect(() => {
                const handleKeyDown = (e) => {
                    keysRef.current[e.key.toLowerCase()] = true;
                    keysRef.current[e.code] = true;

                    // Detectar tecla 'E' para interactuar
                    if ((e.key === 'e' || e.key === 'E') && nearbyObject) {
                        // Buscar el objeto actualizado en la lista
                        const currentObject = interactiveObjects.find(obj => obj.id === nearbyObject.id);
                        if (currentObject) {
                            setSelectedObject(currentObject);
                            selectedObjectRef.current = currentObject;
                        } else {
                            setSelectedObject(nearbyObject);
                            selectedObjectRef.current = nearbyObject;
                        }
                    }
                };

                const handleKeyUp = (e) => {
                    keysRef.current[e.key.toLowerCase()] = false;
                    keysRef.current[e.code] = false;
                };

                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);

                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                    window.removeEventListener('keyup', handleKeyUp);
                };
            }, [nearbyObject]);

            // Calcular objeto cercano basado en distancia
            useEffect(() => {
                const checkNearbyObjects = () => {
                    if (!interactiveObjects || interactiveObjects.length === 0) {
                        setNearbyObject(null);
                        return;
                    }

                    let closestObject = null;
                    let minDistance = Infinity;

                    interactiveObjects.forEach(obj => {
                        // Calcular distancia entre jugador y centro del objeto
                        const objCenterX = obj.position_x + OBJECT_WIDTH / 2;
                        const objCenterY = obj.position_y + OBJECT_HEIGHT / 2;
                        const dx = player.x - objCenterX;
                        const dy = player.y - objCenterY;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < interactionRadius && distance < minDistance) {
                            minDistance = distance;
                            closestObject = obj;
                        }
                    });

                    setNearbyObject(closestObject);
                };

                checkNearbyObjects();
            }, [player, interactiveObjects]);

            // Actualizar posición del jugador y broadcast
            useEffect(() => {
                const updatePlayerPosition = () => {
                    setPlayer(prev => {
                        let newX = prev.x;
                        let newY = prev.y;
                        const keys = keysRef.current;

                        // Movimiento: WASD o flechas
                        if (keys['w'] || keys['ArrowUp']) {
                            newY -= prev.speed;
                        }
                        if (keys['s'] || keys['ArrowDown']) {
                            newY += prev.speed;
                        }
                        if (keys['a'] || keys['ArrowLeft']) {
                            newX -= prev.speed;
                        }
                        if (keys['d'] || keys['ArrowRight']) {
                            newX += prev.speed;
                        }

                        // Limitar movimiento dentro del canvas
                        const canvas = canvasRef.current;
                        if (canvas) {
                            newX = Math.max(prev.radius, Math.min(canvas.width - prev.radius, newX));
                            newY = Math.max(prev.radius, Math.min(canvas.height - prev.radius, newY));
                        }

                        // Broadcast posición con throttle (manejado en el hook)
                        broadcastPosition(newX, newY);

                        return { ...prev, x: newX, y: newY };
                    });
                };

                const interval = setInterval(updatePlayerPosition, 16); // ~60 FPS

                return () => clearInterval(interval);
            }, []);

            // Game loop - renderizado
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                
                // Ajustar tamaño del canvas
                const resizeCanvas = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                };

                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);

                const gameLoop = () => {
                    // Limpiar canvas
                    ctx.fillStyle = '#16213e';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Dibujar objetos interactivos desde la base de datos
                    if (interactiveObjects && interactiveObjects.length > 0) {
                        interactiveObjects.forEach(obj => {
                            // Dibujar rectángulo del objeto
                            ctx.fillStyle = '#8B4513'; // Color marrón
                            ctx.fillRect(obj.position_x, obj.position_y, OBJECT_WIDTH, OBJECT_HEIGHT);
                            
                            // Borde del objeto (verde si está cerca)
                            ctx.strokeStyle = nearbyObject && nearbyObject.id === obj.id ? '#4CAF50' : '#654321';
                            ctx.lineWidth = nearbyObject && nearbyObject.id === obj.id ? 3 : 2;
                            ctx.strokeRect(obj.position_x, obj.position_y, OBJECT_WIDTH, OBJECT_HEIGHT);

                            // Etiqueta del tipo de objeto
                            ctx.fillStyle = 'white';
                            ctx.font = '12px Courier New';
                            ctx.textAlign = 'center';
                            ctx.fillText(
                                obj.type || 'Objeto',
                                obj.position_x + OBJECT_WIDTH / 2,
                                obj.position_y + OBJECT_HEIGHT / 2
                            );
                        });
                    }

                    // Dibujar otros jugadores
                    Object.values(otherPlayers).forEach(otherPlayer => {
                        ctx.beginPath();
                        ctx.arc(otherPlayer.x, otherPlayer.y, player.radius, 0, Math.PI * 2);
                        ctx.fillStyle = otherPlayer.color;
                        ctx.fill();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        // Dibujar nickname sobre el jugador
                        if (otherPlayer.nickname) {
                            ctx.fillStyle = 'white';
                            ctx.font = '12px Courier New';
                            ctx.textAlign = 'center';
                            ctx.fillText(
                                otherPlayer.nickname,
                                otherPlayer.x,
                                otherPlayer.y - player.radius - 8
                            );
                        }
                    });

                    // Dibujar jugador local (círculo)
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
                    ctx.fillStyle = player.color;
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    // Dibujar nickname del jugador local
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText(
                        player.nickname,
                        player.x,
                        player.y - player.radius - 8
                    );

                    // Siguiente frame
                    animationFrameRef.current = requestAnimationFrame(gameLoop);
                };

                gameLoop();

                return () => {
                    window.removeEventListener('resize', resizeCanvas);
                    if (animationFrameRef.current) {
                        cancelAnimationFrame(animationFrameRef.current);
                    }
                };
            }, [player, otherPlayers, interactiveObjects, nearbyObject]);

            return (
                <div className="game-container">
                    <canvas ref={canvasRef}></canvas>
                    {nearbyObject && (
                        <div className="interaction-hint">
                            Presiona E para interactuar
                        </div>
                    )}
                    <div className="ui-overlay">
                        <div>Posición: ({Math.round(player.x)}, {Math.round(player.y)})</div>
                        <div>Jugadores: {Object.keys(otherPlayers).length + 1}</div>
                        {nearbyObject && (
                            <div style={{ marginTop: '8px', color: '#4CAF50' }}>
                                Cerca de: {nearbyObject.type}
                            </div>
                        )}
                        {isAdmin && (
                            <div style={{ marginTop: '8px', color: '#22c55e', fontWeight: 'bold' }}>
                                ⚡ Modo Admin Activo
                            </div>
                        )}
                    </div>
                    <div className="players-list">
                        <h3>En línea ({onlineUsers.length})</h3>
                        {onlineUsers.map(user => (
                            <div key={user.userId} className="player-item">
                                <div
                                    className="player-color-dot"
                                    style={{ backgroundColor: user.color }}
                                />
                                <span>{user.nickname}</span>
                            </div>
                        ))}
                    </div>
                    <div className="controls-hint">
                        <div>Controles: WASD o Flechas del teclado</div>
                        {nearbyObject && (
                            <div style={{ marginTop: '4px' }}>
                                Presiona E para {isAdmin ? 'editar' : 'leer'}
                            </div>
                        )}
                    </div>
                    {selectedObject && (() => {
                        // Buscar el objeto actualizado en la lista para tener siempre la versión más reciente
                        const currentObject = interactiveObjects.find(obj => obj.id === selectedObject.id) || selectedObject;
                        return (
                            <ObjectModal
                                object={currentObject}
                                onClose={() => setSelectedObject(null)}
                                isAdmin={isAdmin}
                                onSave={onSaveObject}
                            />
                        );
                    })()}
                </div>
            );
        };

        // Componente principal App
        const App = () => {
            const [playerData, setPlayerData] = useState(null);
            const [interactiveObjects, setInteractiveObjects] = useState([]);
            const [loading, setLoading] = useState(true);
            const [isAdmin, setIsAdmin] = useState(false);
            const channelRef = useRef(null);

            // Verificar sesión de admin al cargar
            useEffect(() => {
                const checkSession = async () => {
                    const { data: { session } } = await supabase.auth.getSession();
                    if (session) {
                        setIsAdmin(true);
                    }

                    // Escuchar cambios en la autenticación
                    supabase.auth.onAuthStateChange((event, session) => {
                        setIsAdmin(!!session);
                    });
                };

                checkSession();
            }, []);

            // Fetch de objetos interactivos desde Supabase
            useEffect(() => {
                const fetchInteractiveObjects = async () => {
                    try {
                        const { data, error } = await supabase
                            .from('interactive_objects')
                            .select('*')
                            .order('created_at', { ascending: true });

                        if (error) {
                            console.error('Error fetching interactive objects:', error);
                        } else {
                            setInteractiveObjects(data || []);
                        }
                    } catch (err) {
                        console.error('Error:', err);
                    } finally {
                        setLoading(false);
                    }
                };

                fetchInteractiveObjects();
            }, []);

            // Suscribirse a cambios en tiempo real de interactive_objects
            useEffect(() => {
                // Limpiar suscripción anterior si existe
                if (channelRef.current) {
                    supabase.removeChannel(channelRef.current);
                }

                // Crear canal para cambios de la tabla
                const channel = supabase
                    .channel('interactive_objects_changes')
                    .on(
                        'postgres_changes',
                        {
                            event: 'UPDATE',
                            schema: 'public',
                            table: 'interactive_objects'
                        },
                        (payload) => {
                            console.log('Cambio detectado en objeto:', payload);
                            // Actualizar el objeto específico en el estado
                            setInteractiveObjects(prev => 
                                prev.map(obj => 
                                    obj.id === payload.new.id 
                                        ? { ...obj, ...payload.new }
                                        : obj
                                )
                            );
                        }
                    )
                    .on(
                        'postgres_changes',
                        {
                            event: 'INSERT',
                            schema: 'public',
                            table: 'interactive_objects'
                        },
                        (payload) => {
                            console.log('Nuevo objeto insertado:', payload);
                            setInteractiveObjects(prev => [...prev, payload.new]);
                        }
                    )
                    .on(
                        'postgres_changes',
                        {
                            event: 'DELETE',
                            schema: 'public',
                            table: 'interactive_objects'
                        },
                        (payload) => {
                            console.log('Objeto eliminado:', payload);
                            setInteractiveObjects(prev => 
                                prev.filter(obj => obj.id !== payload.old.id)
                            );
                        }
                    )
                    .subscribe();

                channelRef.current = channel;

                return () => {
                    if (channelRef.current) {
                        supabase.removeChannel(channelRef.current);
                        channelRef.current = null;
                    }
                };
            }, []);

            // Función para guardar cambios en un objeto
            const handleSaveObject = async (objectId, newContent) => {
                try {
                    const { data, error } = await supabase
                        .from('interactive_objects')
                        .update({ content: newContent })
                        .eq('id', objectId)
                        .select()
                        .single();

                    if (error) {
                        throw error;
                    }

                    // El cambio se propagará automáticamente vía Realtime
                    console.log('Objeto actualizado exitosamente:', data);
                } catch (error) {
                    console.error('Error al actualizar objeto:', error);
                    throw error;
                }
            };

            const handleLoginSuccess = () => {
                setIsAdmin(true);
            };

            const handleLogout = () => {
                setIsAdmin(false);
            };

            if (!playerData) {
                return (
                    <>
                        <AdminLogin 
                            isAdmin={isAdmin} 
                            onLoginSuccess={handleLoginSuccess}
                            onLogout={handleLogout}
                        />
                        <JoinScreen onJoin={setPlayerData} />
                    </>
                );
            }

            if (loading) {
                return (
                    <>
                        <AdminLogin 
                            isAdmin={isAdmin} 
                            onLoginSuccess={handleLoginSuccess}
                            onLogout={handleLogout}
                        />
                        <div className="join-screen">
                            <div className="join-form">
                                <h2 style={{ color: 'white', textAlign: 'center' }}>
                                    Cargando objetos...
                                </h2>
                            </div>
                        </div>
                    </>
                );
            }

            return (
                <>
                    <AdminLogin 
                        isAdmin={isAdmin} 
                        onLoginSuccess={handleLoginSuccess}
                        onLogout={handleLogout}
                    />
                    <GameCanvas 
                        playerData={playerData} 
                        interactiveObjects={interactiveObjects}
                        isAdmin={isAdmin}
                        onSaveObject={handleSaveObject}
                    />
                </>
            );
        };

        // Renderizar la aplicación
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
