<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mundo Virtual - Aula</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #1a1a2e;
            font-family: 'Courier New', monospace;
        }

        #root {
            width: 100%;
            height: 100%;
        }

        /* Pantalla de Ingreso */
        .join-screen {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }

        .join-form {
            background: rgba(0, 0, 0, 0.8);
            padding: 40px;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            min-width: 350px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .join-form h2 {
            color: white;
            margin-bottom: 30px;
            text-align: center;
            font-size: 24px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            color: white;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .form-group input {
            width: 100%;
            padding: 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 16px;
            font-family: 'Courier New', monospace;
        }

        .form-group input:focus {
            outline: none;
            border-color: #4CAF50;
            background: rgba(255, 255, 255, 0.15);
        }

        .color-picker {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .color-option {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
        }

        .color-option:hover {
            transform: scale(1.1);
            border-color: white;
        }

        .color-option.selected {
            border-color: white;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
        }

        .join-button {
            width: 100%;
            padding: 14px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: background 0.2s;
        }

        .join-button:hover {
            background: #45a049;
        }

        .join-button:disabled {
            background: #666;
            cursor: not-allowed;
        }

        /* Game Container */
        .game-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        canvas {
            display: block;
            background: #16213e;
        }

        .ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 10;
        }

        .players-list {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 10;
            min-width: 200px;
        }

        .players-list h3 {
            margin-bottom: 8px;
            font-size: 14px;
        }

        .player-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            padding: 4px;
        }

        .player-color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            border: 1px solid white;
        }

        .controls-hint {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 5px;
            z-index: 10;
        }

        .admin-button {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 15;
            padding: 8px 16px;
            background: rgba(55, 65, 81, 0.9);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
        }

        .admin-button:hover {
            background: rgba(75, 85, 99, 0.9);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .admin-button.admin-active {
            background: rgba(34, 197, 94, 0.9);
            border-color: rgba(34, 197, 94, 1);
        }

        .reactions-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            z-index: 15;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .reaction-button {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            font-size: 13px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .reaction-button:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px);
        }

        .reaction-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .reaction-button:active:not(:disabled) {
            transform: translateY(0);
        }

        .interaction-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 16px;
            background: rgba(76, 175, 80, 0.9);
            padding: 12px 20px;
            border-radius: 8px;
            z-index: 20;
            pointer-events: none;
            animation: pulse 1.5s ease-in-out infinite;
            border: 2px solid white;
            font-weight: bold;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            50% {
                opacity: 0.8;
                transform: translate(-50%, -50%) scale(1.05);
            }
        }

        /* Restricción móvil */
        .mobile-restriction {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000;
            color: white;
            font-size: 24px;
            text-align: center;
            z-index: 10000;
            align-items: center;
            justify-content: center;
            font-family: 'Courier New', monospace;
        }

        .mobile-restriction.active {
            display: flex;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // Configuración de Supabase
        const SUPABASE_URL = 'https://qkryjldoiandvrqqxszc.supabase.co';
        const SUPABASE_ANON_KEY = 'sb_publishable_qP8lp3-rT-f_6svcadtaHQ_b_KoqnmY';

        // Inicializar Supabase
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // Dimensiones del Mundo (fijas)
        const WORLD_WIDTH = 2000;
        const WORLD_HEIGHT = 1500;

        // Colores disponibles
        const AVAILABLE_COLORS = [
            '#4CAF50', // Verde
            '#2196F3', // Azul
            '#FF9800', // Naranja
            '#F44336', // Rojo
            '#9C27B0', // Púrpura
            '#00BCD4', // Cyan
            '#FFEB3B', // Amarillo
            '#E91E63', // Rosa
            '#795548', // Marrón
            '#607D8B', // Azul gris
            '#FF5722', // Naranja oscuro
            '#3F51B5'  // Índigo
        ];

        // Mensajes predefinidos
        const PRESET_MESSAGES = [
            { id: 'hello', text: 'Hola', color: '#FFFFFF' },
            { id: 'not_understood', text: 'No entendí', color: '#F44336' },
            { id: 'understood', text: 'Ahora entiendo', color: '#4CAF50' },
            { id: 'confused', text: 'Estoy confundido', color: '#FF9800' },
            { id: 'question', text: 'Tengo una duda', color: '#FFFFFF' }
        ];

        // Hook useMultiplayer
        const useMultiplayer = (playerData, onMessageReceived) => {
            const channelRef = useRef(null);
            const [otherPlayers, setOtherPlayers] = useState({});
            const [onlineUsers, setOnlineUsers] = useState([]);
            const lastBroadcastRef = useRef(0);
            const throttleMs = 80; // Throttle de 80ms
            const broadcastPositionRef = useRef(null);

            useEffect(() => {
                if (!playerData) return;

                // Crear canal de Realtime
                const channel = supabase.channel('classroom_1', {
                    config: {
                        broadcast: { self: true },
                        presence: { key: playerData.userId }
                    }
                });

                // Suscribirse a presencia (quién está online)
                channel.on('presence', { event: 'sync' }, () => {
                    const presenceState = channel.presenceState();
                    const users = [];
                    Object.keys(presenceState).forEach(userId => {
                        const presences = presenceState[userId];
                        if (presences && presences.length > 0) {
                            const presence = presences[0];
                            users.push({
                                userId: userId,
                                nickname: presence.nickname || 'Anónimo',
                                color: presence.color || '#4CAF50'
                            });
                        }
                    });
                    setOnlineUsers(users);
                });

                // Suscribirse a broadcast (posiciones de otros jugadores)
                channel.on('broadcast', { event: 'position' }, (payload) => {
                    const { userId, x, y, color, nickname } = payload.payload;
                    if (userId !== playerData.userId) {
                        setOtherPlayers(prev => ({
                            ...prev,
                            [userId]: { x, y, color, nickname, userId }
                        }));
                    }
                });

                // Suscribirse a broadcast (mensajes/reacciones)
                channel.on('broadcast', { event: 'message' }, (payload) => {
                    const { userId, messageType, content } = payload.payload;
                    if (onMessageReceived) {
                        onMessageReceived({ userId, messageType, content });
                    }
                });

                // Suscribirse al canal
                channel.subscribe(async (status) => {
                    if (status === 'SUBSCRIBED') {
                        // Enviar presencia inicial
                        await channel.track({
                            userId: playerData.userId,
                            nickname: playerData.nickname,
                            color: playerData.color,
                            x: playerData.x || 400,
                            y: playerData.y || 300
                        });
                    }
                });

                channelRef.current = channel;

                // Función para enviar posición con throttle
                broadcastPositionRef.current = (x, y) => {
                    const now = Date.now();
                    if (now - lastBroadcastRef.current < throttleMs) {
                        return;
                    }
                    lastBroadcastRef.current = now;

                    if (channel && playerData) {
                        channel.send({
                            type: 'broadcast',
                            event: 'position',
                            payload: {
                                userId: playerData.userId,
                                x: Math.round(x),
                                y: Math.round(y),
                                color: playerData.color,
                                nickname: playerData.nickname
                            }
                        });
                    }
                };

                return () => {
                    if (channelRef.current) {
                        channelRef.current.unsubscribe();
                        channelRef.current = null;
                    }
                    broadcastPositionRef.current = null;
                };
            }, [playerData]);

            // Retornar función wrapper que siempre verifica el ref
            const broadcastPosition = useCallback((x, y) => {
                if (broadcastPositionRef.current) {
                    broadcastPositionRef.current(x, y);
                }
            }, []);

            // Función para enviar mensaje
            const broadcastMessage = useCallback((messageType, content) => {
                if (channelRef.current && playerData) {
                    channelRef.current.send({
                        type: 'broadcast',
                        event: 'message',
                        payload: {
                            userId: playerData.userId,
                            messageType: messageType,
                            content: content
                        }
                    });
                }
            }, [playerData]);

            return { otherPlayers, onlineUsers, broadcastPosition, broadcastMessage };
        };

        // Componente JoinScreen
        const JoinScreen = ({ onJoin }) => {
            const [nickname, setNickname] = useState('');
            const [selectedColor, setSelectedColor] = useState(AVAILABLE_COLORS[0]);

            const handleSubmit = (e) => {
                e.preventDefault();
                if (nickname.trim()) {
                    const userId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                    onJoin({
                        userId,
                        nickname: nickname.trim(),
                        color: selectedColor
                    });
                }
            };

            return (
                <div className="join-screen">
                    <form className="join-form" onSubmit={handleSubmit}>
                        <h2>Unirse al Aula Virtual</h2>
                        <div className="form-group">
                            <label htmlFor="nickname">Nickname:</label>
                            <input
                                id="nickname"
                                type="text"
                                value={nickname}
                                onChange={(e) => setNickname(e.target.value)}
                                placeholder="Ingresa tu nombre"
                                maxLength={20}
                                required
                                autoFocus
                            />
                        </div>
                        <div className="form-group">
                            <label>Elige tu color:</label>
                            <div className="color-picker">
                                {AVAILABLE_COLORS.map((color) => (
                                    <div
                                        key={color}
                                        className={`color-option ${selectedColor === color ? 'selected' : ''}`}
                                        style={{ backgroundColor: color }}
                                        onClick={() => setSelectedColor(color)}
                                    />
                                ))}
                            </div>
                        </div>
                        <button
                            type="submit"
                            className="join-button"
                            disabled={!nickname.trim()}
                        >
                            Entrar al Aula
                        </button>
                    </form>
                </div>
            );
        };

        // Componente AdminLogin
        const AdminLogin = ({ isAdmin, onLoginSuccess, onLogout }) => {
            const [showLogin, setShowLogin] = useState(false);
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [error, setError] = useState('');
            const [loading, setLoading] = useState(false);

            const handleLogin = async (e) => {
                e.preventDefault();
                setError('');
                setLoading(true);

                try {
                    const { data, error: authError } = await supabase.auth.signInWithPassword({
                        email: email.trim(),
                        password: password
                    });

                    if (authError) {
                        setError(authError.message);
                    } else {
                        onLoginSuccess();
                        setShowLogin(false);
                        setEmail('');
                        setPassword('');
                    }
                } catch (err) {
                    setError('Error al iniciar sesión');
                    console.error(err);
                } finally {
                    setLoading(false);
                }
            };

            const handleLogout = async () => {
                await supabase.auth.signOut();
                onLogout();
            };

            if (isAdmin) {
                return (
                    <>
                        <button
                            className="admin-button admin-active"
                            onClick={handleLogout}
                            title="Cerrar sesión de admin"
                        >
                            Admin: Conectado
                        </button>
                    </>
                );
            }

            return (
                <>
                    <button
                        className="admin-button"
                        onClick={() => setShowLogin(!showLogin)}
                    >
                        Admin Login
                    </button>
                    {showLogin && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                            <div className="bg-white rounded-lg shadow-xl max-w-md w-full mx-4">
                                <div className="bg-gray-800 text-white px-6 py-4 flex justify-between items-center">
                                    <h2 className="text-xl font-bold">Login de Admin</h2>
                                    <button
                                        onClick={() => {
                                            setShowLogin(false);
                                            setError('');
                                        }}
                                        className="text-white hover:text-gray-300 text-2xl font-bold"
                                    >
                                        ×
                                    </button>
                                </div>
                                <form onSubmit={handleLogin} className="p-6">
                                    {error && (
                                        <div className="mb-4 p-3 bg-red-100 border border-red-400 text-red-700 rounded">
                                            {error}
                                        </div>
                                    )}
                                    <div className="mb-4">
                                        <label className="block text-gray-700 text-sm font-bold mb-2">
                                            Email:
                                        </label>
                                        <input
                                            type="email"
                                            value={email}
                                            onChange={(e) => setEmail(e.target.value)}
                                            className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:border-gray-800"
                                            required
                                            autoFocus
                                        />
                                    </div>
                                    <div className="mb-6">
                                        <label className="block text-gray-700 text-sm font-bold mb-2">
                                            Contraseña:
                                        </label>
                                        <input
                                            type="password"
                                            value={password}
                                            onChange={(e) => setPassword(e.target.value)}
                                            className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:border-gray-800"
                                            required
                                        />
                                    </div>
                                    <div className="flex justify-end gap-3">
                                        <button
                                            type="button"
                                            onClick={() => {
                                                setShowLogin(false);
                                                setError('');
                                            }}
                                            className="px-4 py-2 border border-gray-300 rounded hover:bg-gray-100 transition"
                                            disabled={loading}
                                        >
                                            Cancelar
                                        </button>
                                        <button
                                            type="submit"
                                            className="px-4 py-2 bg-gray-800 text-white rounded hover:bg-gray-700 transition"
                                            disabled={loading}
                                        >
                                            {loading ? 'Iniciando...' : 'Iniciar Sesión'}
                                        </button>
                                    </div>
                                </form>
                            </div>
                        </div>
                    )}
                </>
            );
        };

        // Componente Modal
        const ObjectModal = ({ object, onClose, isAdmin, onSave }) => {
            const [content, setContent] = useState(object?.content || '');
            const [saving, setSaving] = useState(false);

            useEffect(() => {
                if (object) {
                    setContent(object.content || '');
                }
            }, [object]);

            if (!object) return null;

            const handleSave = async () => {
                if (!isAdmin) return;
                
                setSaving(true);
                try {
                    await onSave(object.id, content);
                    onClose();
                } catch (error) {
                    console.error('Error al guardar:', error);
                    alert('Error al guardar los cambios');
                } finally {
                    setSaving(false);
                }
            };

            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                    <div className="bg-white rounded-lg shadow-xl max-w-2xl w-full mx-4 max-h-[80vh] overflow-hidden flex flex-col">
                        <div className="bg-gray-800 text-white px-6 py-4 flex justify-between items-center">
                            <h2 className="text-xl font-bold">
                                Pizarra: {object.type}
                                {isAdmin && <span className="ml-2 text-sm text-green-300">(Modo Edición)</span>}
                            </h2>
                            <button
                                onClick={onClose}
                                className="text-white hover:text-gray-300 text-2xl font-bold"
                            >
                                ×
                            </button>
                        </div>
                        <div className="p-6 overflow-y-auto flex-1">
                            {isAdmin ? (
                                <textarea
                                    value={content}
                                    onChange={(e) => setContent(e.target.value)}
                                    className="w-full h-full p-4 border border-gray-300 rounded font-mono text-sm focus:outline-none focus:border-gray-800 resize-none"
                                    placeholder="Escribe el contenido de la pizarra aquí..."
                                />
                            ) : (
                                <div className="whitespace-pre-wrap text-gray-800 font-mono">
                                    {object.content || '(Vacío)'}
                                </div>
                            )}
                        </div>
                        <div className="bg-gray-100 px-6 py-4 flex justify-between">
                            <button
                                onClick={onClose}
                                className="px-6 py-2 border border-gray-300 rounded hover:bg-gray-200 transition"
                            >
                                Cerrar
                            </button>
                            {isAdmin && (
                                <button
                                    onClick={handleSave}
                                    disabled={saving}
                                    className="px-6 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition disabled:bg-gray-400 disabled:cursor-not-allowed"
                                >
                                    {saving ? 'Guardando...' : 'Guardar Cambios'}
                                </button>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // Componente ReactionsBar
        const ReactionsBar = ({ onSendMessage, cooldownActive }) => {
            return (
                <div className="reactions-bar">
                    {PRESET_MESSAGES.map(msg => (
                        <button
                            key={msg.id}
                            className="reaction-button"
                            onClick={() => onSendMessage(msg.id, msg.text)}
                            disabled={cooldownActive}
                        >
                            {msg.text}
                        </button>
                    ))}
                </div>
            );
        };

        // Componente GameCanvas
        const GameCanvas = ({ playerData, interactiveObjects, isAdmin, onSaveObject }) => {
            const canvasRef = useRef(null);
            const animationFrameRef = useRef(null);
            
            // Estado del jugador local
            const [player, setPlayer] = useState({
                x: 400,
                y: 300,
                color: playerData.color,
                nickname: playerData.nickname,
                radius: 15,
                speed: 3
            });

            // Estado para mensajes activos (animaciones)
            const [activeMessages, setActiveMessages] = useState([]);
            const [cooldownActive, setCooldownActive] = useState(false);
            const lastMessageTimeRef = useRef(0);

            // Estado para objeto cercano y modal
            const [nearbyObject, setNearbyObject] = useState(null);
            const [selectedObject, setSelectedObject] = useState(null);
            const selectedObjectRef = useRef(null);
            const interactionRadius = 50; // Radio de interacción en píxeles
            const OBJECT_WIDTH = 200;
            const OBJECT_HEIGHT = 150;

            // Estado de la cámara
            const [camera, setCamera] = useState({ x: 0, y: 0 });

            // Estado para click-to-move
            const [targetPosition, setTargetPosition] = useState(null);
            const [clickFeedback, setClickFeedback] = useState(null);

            // Estados para imágenes
            const [semillaImg, setSemillaImg] = useState(null);
            const [backgroundImg, setBackgroundImg] = useState(null);
            const [imagesLoaded, setImagesLoaded] = useState(false);

            // Mobiliario hardcoded (obstáculos sólidos)
            // Escritorio del profesor: cerca de la pizarra
            // Mesas de alumnos: distribuidas en el aula
            // Usar useMemo para evitar recrear el array en cada render
            const furniture = React.useMemo(() => [
                // Escritorio del profesor (cerca de la pizarra)
                { x: 100, y: 100, width: 120, height: 80, type: 'desk', label: 'Escritorio Profesor' },
                // Mesas de alumnos (distribuidas)
                { x: 300, y: 200, width: 100, height: 60, type: 'table', label: 'Mesa Alumno' },
                { x: 450, y: 200, width: 100, height: 60, type: 'table', label: 'Mesa Alumno' },
                { x: 600, y: 200, width: 100, height: 60, type: 'table', label: 'Mesa Alumno' },
                { x: 300, y: 350, width: 100, height: 60, type: 'table', label: 'Mesa Alumno' },
                { x: 450, y: 350, width: 100, height: 60, type: 'table', label: 'Mesa Alumno' },
                { x: 600, y: 350, width: 100, height: 60, type: 'table', label: 'Mesa Alumno' }
            ], []);

            // Función para dibujar el grid del suelo
            const drawGrid = (ctx) => {
                const gridSize = 40; // Tamaño de cada celda del grid
                ctx.strokeStyle = 'rgba(200, 200, 220, 0.15)'; // Gris muy claro, casi transparente
                ctx.lineWidth = 1;

                // Líneas verticales
                for (let x = 0; x <= WORLD_WIDTH; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, WORLD_HEIGHT);
                    ctx.stroke();
                }

                // Líneas horizontales
                for (let y = 0; y <= WORLD_HEIGHT; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(WORLD_WIDTH, y);
                    ctx.stroke();
                }
            };

            // Función para verificar colisión entre círculo (jugador) y rectángulo (objeto/mueble)
            const checkCollision = (playerX, playerY, playerRadius, rectX, rectY, rectWidth, rectHeight) => {
                // Encontrar el punto más cercano en el rectángulo al centro del círculo
                const closestX = Math.max(rectX, Math.min(playerX, rectX + rectWidth));
                const closestY = Math.max(rectY, Math.min(playerY, rectY + rectHeight));

                // Calcular distancia entre el centro del círculo y el punto más cercano
                const dx = playerX - closestX;
                const dy = playerY - closestY;

                // Si la distancia es menor que el radio, hay colisión
                return (dx * dx + dy * dy) < (playerRadius * playerRadius);
            };

            // Handler para recibir mensajes
            const handleMessageReceived = useCallback(({ userId, messageType, content }) => {
                const presetMsg = PRESET_MESSAGES.find(m => m.id === messageType || m.text === content);
                const messageColor = presetMsg ? presetMsg.color : '#FFFFFF';
                
                // Crear mensaje animado
                const messageId = `${userId}_${Date.now()}`;
                const newMessage = {
                    id: messageId,
                    userId: userId,
                    content: content,
                    color: messageColor,
                    startTime: Date.now()
                };
                
                setActiveMessages(prev => [...prev, newMessage]);
                
                // Eliminar mensaje después de 4 segundos
                setTimeout(() => {
                    setActiveMessages(prev => prev.filter(m => m.id !== messageId));
                }, 4000);
            }, []);

            // Hook de multiplayer (debe estar antes de handleSendMessage)
            const { otherPlayers, onlineUsers, broadcastPosition, broadcastMessage } = useMultiplayer(playerData, handleMessageReceived);

            // Función para enviar mensaje con cooldown
            const handleSendMessage = useCallback((messageType, content) => {
                const now = Date.now();
                const cooldownMs = 2000; // 2 segundos

                if (now - lastMessageTimeRef.current < cooldownMs) {
                    return;
                }

                lastMessageTimeRef.current = now;
                setCooldownActive(true);

                // Enviar mensaje
                broadcastMessage(messageType, content);

                // Crear mensaje local inmediatamente
                const presetMsg = PRESET_MESSAGES.find(m => m.id === messageType);
                const messageColor = presetMsg ? presetMsg.color : '#FFFFFF';
                const messageId = `${playerData.userId}_${Date.now()}`;
                const newMessage = {
                    id: messageId,
                    userId: playerData.userId,
                    content: content,
                    color: messageColor,
                    startTime: Date.now()
                };

                setActiveMessages(prev => [...prev, newMessage]);

                // Eliminar mensaje después de 4 segundos
                setTimeout(() => {
                    setActiveMessages(prev => prev.filter(m => m.id !== messageId));
                }, 4000);

                // Liberar cooldown después de 2 segundos
                setTimeout(() => {
                    setCooldownActive(false);
                }, cooldownMs);
            }, [broadcastMessage, playerData.userId]);

            // Actualizar objeto seleccionado cuando cambie desde Realtime
            useEffect(() => {
                if (selectedObject && interactiveObjects) {
                    const updatedObject = interactiveObjects.find(obj => obj.id === selectedObject.id);
                    if (updatedObject) {
                        setSelectedObject(updatedObject);
                        selectedObjectRef.current = updatedObject;
                    }
                }
            }, [interactiveObjects]);

            // Manejo de teclado (solo para interacción con tecla 'E')
            useEffect(() => {
                const handleKeyDown = (e) => {
                    // Detectar tecla 'E' para interactuar
                    if ((e.key === 'e' || e.key === 'E') && nearbyObject) {
                        // Buscar el objeto actualizado en la lista
                        const currentObject = interactiveObjects.find(obj => obj.id === nearbyObject.id);
                        if (currentObject) {
                            setSelectedObject(currentObject);
                            selectedObjectRef.current = currentObject;
                        } else {
                            setSelectedObject(nearbyObject);
                            selectedObjectRef.current = nearbyObject;
                        }
                    }
                };

                window.addEventListener('keydown', handleKeyDown);

                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                };
            }, [nearbyObject, interactiveObjects]);

            // Cargar imágenes
            useEffect(() => {
                const loadImages = async () => {
                    const semillaImage = new Image();
                    const backgroundImage = new Image();
                    
                    let semillaLoaded = false;
                    let backgroundLoaded = false;

                    const checkAllLoaded = () => {
                        if (semillaLoaded && backgroundLoaded) {
                            setImagesLoaded(true);
                        }
                    };

                    semillaImage.onload = () => {
                        setSemillaImg(semillaImage);
                        semillaLoaded = true;
                        checkAllLoaded();
                    };
                    semillaImage.onerror = () => {
                        console.error('Error cargando semilla.png');
                        semillaLoaded = true;
                        checkAllLoaded();
                    };
                    semillaImage.src = './semilla.png';

                    backgroundImage.onload = () => {
                        setBackgroundImg(backgroundImage);
                        backgroundLoaded = true;
                        checkAllLoaded();
                    };
                    backgroundImage.onerror = () => {
                        console.error('Error cargando background.png');
                        backgroundLoaded = true;
                        checkAllLoaded();
                    };
                    backgroundImage.src = './background.png';
                };

                loadImages();
            }, []);

            // Función helper para dibujar jugador con imagen tintada (usando canvas offscreen con multiply para preservar detalles)
            const drawTintedPlayer = useCallback((ctx, x, y, color, radius, img) => {
                if (!img || !img.complete) {
                    // Fallback a círculo si la imagen no está cargada
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    return;
                }

                const imgSize = radius * 2;
                
                // Crear canvas offscreen para aplicar tintado preservando detalles
                const offscreenCanvas = document.createElement('canvas');
                offscreenCanvas.width = imgSize;
                offscreenCanvas.height = imgSize;
                const offscreenCtx = offscreenCanvas.getContext('2d');
                
                // Paso A: Limpiar el canvas offscreen
                offscreenCtx.clearRect(0, 0, imgSize, imgSize);
                
                // Paso B: Dibujar la imagen original normalmente (source-over por defecto)
                offscreenCtx.drawImage(img, 0, 0, imgSize, imgSize);
                
                // Paso C: Cambiar a 'multiply' para multiplicar el color con los píxeles existentes
                offscreenCtx.globalCompositeOperation = 'multiply';
                
                // Paso D: Dibujar el rectángulo del color sobre todo el canvas offscreen
                offscreenCtx.fillStyle = color;
                offscreenCtx.fillRect(0, 0, imgSize, imgSize);
                
                // Paso 4: Dibujar el resultado en el canvas principal
                ctx.save();
                ctx.globalCompositeOperation = 'source-over';
                ctx.drawImage(offscreenCanvas, x - radius, y - radius);
                ctx.restore();
            }, []);

            // Calcular objeto cercano basado en distancia
            useEffect(() => {
                const checkNearbyObjects = () => {
                    if (!interactiveObjects || interactiveObjects.length === 0) {
                        setNearbyObject(null);
                        return;
                    }

                    let closestObject = null;
                    let minDistance = Infinity;

                    interactiveObjects.forEach(obj => {
                        // Calcular distancia entre jugador y centro del objeto
                        const objCenterX = obj.position_x + OBJECT_WIDTH / 2;
                        const objCenterY = obj.position_y + OBJECT_HEIGHT / 2;
                        const dx = player.x - objCenterX;
                        const dy = player.y - objCenterY;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < interactionRadius && distance < minDistance) {
                            minDistance = distance;
                            closestObject = obj;
                        }
                    });

                    setNearbyObject(closestObject);
                };

                checkNearbyObjects();
            }, [player, interactiveObjects]);

            // Handler de click en el canvas (click-to-move)
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;

                const handleCanvasClick = (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    // Convertir coordenadas de pantalla a coordenadas del mundo
                    // CRÍTICO: WorldX = MouseX + CameraX
                    const worldX = mouseX + camera.x;
                    const worldY = mouseY + camera.y;

                    // Validar que el click esté dentro del mundo
                    if (worldX >= 0 && worldX <= WORLD_WIDTH && worldY >= 0 && worldY <= WORLD_HEIGHT) {
                        setTargetPosition({ x: worldX, y: worldY });

                        // Feedback visual: mostrar marca por 0.5s
                        setClickFeedback({ x: worldX, y: worldY, startTime: Date.now() });
                        setTimeout(() => {
                            setClickFeedback(null);
                        }, 500);
                    }
                };

                canvas.addEventListener('click', handleCanvasClick);

                return () => {
                    canvas.removeEventListener('click', handleCanvasClick);
                };
            }, [camera]);

            // Actualizar cámara para seguir al jugador
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;

                const updateCamera = () => {
                    // La cámara debe mantener al jugador en el centro de la pantalla
                    let targetCameraX = player.x - canvas.width / 2;
                    let targetCameraY = player.y - canvas.height / 2;

                    // Clamping: la cámara no debe salirse de los límites del mundo
                    const minCameraX = 0;
                    const maxCameraX = WORLD_WIDTH - canvas.width;
                    const minCameraY = 0;
                    const maxCameraY = WORLD_HEIGHT - canvas.height;

                    // Aplicar clamping solo si el mundo es más grande que el canvas
                    if (WORLD_WIDTH > canvas.width) {
                        targetCameraX = Math.max(minCameraX, Math.min(maxCameraX, targetCameraX));
                    } else {
                        targetCameraX = (WORLD_WIDTH - canvas.width) / 2;
                    }

                    if (WORLD_HEIGHT > canvas.height) {
                        targetCameraY = Math.max(minCameraY, Math.min(maxCameraY, targetCameraY));
                    } else {
                        targetCameraY = (WORLD_HEIGHT - canvas.height) / 2;
                    }

                    setCamera({ x: targetCameraX, y: targetCameraY });
                };

                updateCamera();
            }, [player]);

            // Actualizar posición del jugador (click-to-move) y broadcast
            useEffect(() => {
                const updatePlayerPosition = () => {
                    setPlayer(prev => {
                        // Si no hay targetPosition, no mover
                        if (!targetPosition) {
                            return prev;
                        }

                        let newX = prev.x;
                        let newY = prev.y;

                        // Calcular vector hacia el target
                        const dx = targetPosition.x - prev.x;
                        const dy = targetPosition.y - prev.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        // Si estamos muy cerca (menos de 5px), detener y encajar en la posición final
                        if (distance < 5) {
                            const finalX = targetPosition.x;
                            const finalY = targetPosition.y;
                            setTargetPosition(null);
                            newX = finalX;
                            newY = finalY;
                        } else {
                            // Normalizar el vector y mover
                            const moveX = (dx / distance) * prev.speed;
                            const moveY = (dy / distance) * prev.speed;
                            newX = prev.x + moveX;
                            newY = prev.y + moveY;
                        }

                        // Verificar límites del mundo (World Bounds)
                        const minX = prev.radius;
                        const maxX = WORLD_WIDTH - prev.radius;
                        const minY = prev.radius;
                        const maxY = WORLD_HEIGHT - prev.radius;
                        
                        // Clamping: si se sale, bloquear el movimiento
                        newX = Math.max(minX, Math.min(maxX, newX));
                        newY = Math.max(minY, Math.min(maxY, newY));

                        // Verificar colisiones con objetos interactivos (pizarra)
                        let collision = false;
                        if (interactiveObjects && interactiveObjects.length > 0) {
                            interactiveObjects.forEach(obj => {
                                if (checkCollision(newX, newY, prev.radius, 
                                    obj.position_x, obj.position_y, OBJECT_WIDTH, OBJECT_HEIGHT)) {
                                    // Colisión detectada: DETENER MOVIMIENTO
                                    collision = true;
                                }
                            });
                        }

                        // Verificar colisiones con mobiliario
                        furniture.forEach(item => {
                            if (checkCollision(newX, newY, prev.radius, 
                                item.x, item.y, item.width, item.height)) {
                                // Colisión detectada: DETENER MOVIMIENTO
                                collision = true;
                            }
                        });

                        // Si hay colisión, detener el movimiento
                        if (collision) {
                            setTargetPosition(null);
                            newX = prev.x;
                            newY = prev.y;
                        }

                        // Broadcast posición con throttle (manejado en el hook)
                        broadcastPosition(newX, newY);

                        return { ...prev, x: newX, y: newY };
                    });
                };

                const interval = setInterval(updatePlayerPosition, 16); // ~60 FPS

                return () => clearInterval(interval);
            }, [targetPosition, interactiveObjects, furniture, broadcastPosition]);

            // Game loop - renderizado
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                
                // Ajustar tamaño del canvas
                const resizeCanvas = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                };

                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);

                const gameLoop = () => {
                    // Limpiar canvas con fondo oscuro
                    ctx.fillStyle = '#1a1a2e'; // Fondo más oscuro
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Guardar estado del contexto
                    ctx.save();

                    // Aplicar transformación de cámara (trasladar)
                    ctx.translate(-camera.x, -camera.y);

                    // Dibujar fondo del mundo con patrón tiling
                    if (backgroundImg) {
                        const pattern = ctx.createPattern(backgroundImg, 'repeat');
                        if (pattern) {
                            ctx.fillStyle = pattern;
                            ctx.fillRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
                        } else {
                            // Fallback si createPattern falla
                            ctx.fillStyle = '#16213e';
                            ctx.fillRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
                        }
                    } else {
                        // Fallback si la imagen no está cargada
                        ctx.fillStyle = '#16213e';
                        ctx.fillRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
                    }

                    // Dibujar borde rojo grueso del mundo
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 8;
                    ctx.strokeRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

                    // Dibujar mobiliario (obstáculos sólidos)
                    furniture.forEach(item => {
                        // Color según tipo de mueble
                        if (item.type === 'desk') {
                            ctx.fillStyle = '#5d4037'; // Marrón oscuro para escritorio
                        } else {
                            ctx.fillStyle = '#6d4c41'; // Marrón medio para mesas
                        }
                        
                        ctx.fillRect(item.x, item.y, item.width, item.height);
                        
                        // Borde
                        ctx.strokeStyle = '#4e342e';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(item.x, item.y, item.width, item.height);
                        
                        // Etiqueta (opcional, pequeña)
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                        ctx.font = '10px Courier New';
                        ctx.textAlign = 'center';
                        ctx.fillText(
                            item.label,
                            item.x + item.width / 2,
                            item.y + item.height / 2
                        );
                    });

                    // Dibujar objetos interactivos desde la base de datos (pizarra)
                    if (interactiveObjects && interactiveObjects.length > 0) {
                        interactiveObjects.forEach(obj => {
                            // Dibujar rectángulo del objeto
                            ctx.fillStyle = '#8B4513'; // Color marrón
                            ctx.fillRect(obj.position_x, obj.position_y, OBJECT_WIDTH, OBJECT_HEIGHT);
                            
                            // Borde del objeto (verde si está cerca)
                            ctx.strokeStyle = nearbyObject && nearbyObject.id === obj.id ? '#4CAF50' : '#654321';
                            ctx.lineWidth = nearbyObject && nearbyObject.id === obj.id ? 3 : 2;
                            ctx.strokeRect(obj.position_x, obj.position_y, OBJECT_WIDTH, OBJECT_HEIGHT);

                            // Etiqueta del tipo de objeto
                            ctx.fillStyle = 'white';
                            ctx.font = '12px Courier New';
                            ctx.textAlign = 'center';
                            ctx.fillText(
                                obj.type || 'Objeto',
                                obj.position_x + OBJECT_WIDTH / 2,
                                obj.position_y + OBJECT_HEIGHT / 2
                            );
                        });
                    }

                    // Dibujar otros jugadores
                    Object.values(otherPlayers).forEach(otherPlayer => {
                        drawTintedPlayer(ctx, otherPlayer.x, otherPlayer.y, otherPlayer.color, player.radius, semillaImg);

                        // Dibujar nickname sobre el jugador
                        if (otherPlayer.nickname) {
                            ctx.fillStyle = 'white';
                            ctx.font = '12px Courier New';
                            ctx.textAlign = 'center';
                            ctx.fillText(
                                otherPlayer.nickname,
                                otherPlayer.x,
                                otherPlayer.y - player.radius - 8
                            );
                        }
                    });

                    // Dibujar jugador local
                    drawTintedPlayer(ctx, player.x, player.y, player.color, player.radius, semillaImg);

                    // Dibujar nickname del jugador local
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText(
                        player.nickname,
                        player.x,
                        player.y - player.radius - 8
                    );

                    // Dibujar mensajes/reacciones animadas
                    const now = Date.now();
                    activeMessages.forEach(message => {
                        // Calcular posición del jugador asociado (se actualiza en cada frame)
                        let playerX, playerY, playerRadius;
                        if (message.userId === playerData.userId) {
                            // Mensaje del jugador local
                            playerX = player.x;
                            playerY = player.y;
                            playerRadius = player.radius;
                        } else {
                            // Mensaje de otro jugador
                            const otherPlayer = otherPlayers[message.userId];
                            if (!otherPlayer) return; // Si el jugador ya no está, no dibujar
                            playerX = otherPlayer.x;
                            playerY = otherPlayer.y;
                            playerRadius = player.radius; // Usar el mismo radio que el jugador local
                        }

                        // Calcular tiempo transcurrido y animación
                        const elapsed = now - message.startTime;
                        const duration = 4000; // 4 segundos
                        const progress = Math.min(elapsed / duration, 1);
                        
                        // Animación: flotar hacia arriba y desvanecerse
                        const floatDistance = 40;
                        const offsetY = -floatDistance * progress;
                        const opacity = 1 - progress;

                        if (opacity <= 0) return;

                        // Calcular posición inicial (arriba del jugador)
                        let finalX = playerX;
                        let finalY = playerY - playerRadius - 20 + offsetY;

                        // Boundary checks - ajustar posición para que no se salga del canvas
                        ctx.font = '14px Courier New';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        const textMetrics = ctx.measureText(message.content);
                        const textWidth = textMetrics.width;
                        const textHeight = 16;
                        const textPadding = 10;
                        const bgPadding = 6;

                        // Ajustar horizontalmente si está cerca del borde del mundo
                        if (finalX - textWidth / 2 - bgPadding < textPadding) {
                            finalX = textWidth / 2 + bgPadding + textPadding;
                        } else if (finalX + textWidth / 2 + bgPadding > WORLD_WIDTH - textPadding) {
                            finalX = WORLD_WIDTH - textWidth / 2 - bgPadding - textPadding;
                        }

                        // Ajustar verticalmente si está cerca del borde del mundo
                        if (finalY - textHeight / 2 - bgPadding < textPadding) {
                            // Dibujar debajo del jugador si está muy arriba
                            finalY = playerY + playerRadius + 20 + Math.abs(offsetY);
                        } else if (finalY + textHeight / 2 + bgPadding > WORLD_HEIGHT - textPadding) {
                            finalY = WORLD_HEIGHT - textHeight / 2 - bgPadding - textPadding;
                        }

                        // Dibujar fondo semitransparente para legibilidad
                        ctx.fillStyle = `rgba(0, 0, 0, ${0.6 * opacity})`;
                        ctx.fillRect(
                            finalX - textWidth / 2 - bgPadding,
                            finalY - textHeight / 2 - bgPadding,
                            textWidth + bgPadding * 2,
                            textHeight + bgPadding * 2
                        );

                        // Borde del texto (negro) para legibilidad
                        ctx.strokeStyle = `rgba(0, 0, 0, ${0.8 * opacity})`;
                        ctx.lineWidth = 3;
                        ctx.strokeText(message.content, finalX, finalY);
                        
                        // Texto principal (con color según tipo)
                        ctx.fillStyle = message.color;
                        ctx.globalAlpha = opacity;
                        ctx.fillText(message.content, finalX, finalY);
                        ctx.globalAlpha = 1;
                    });

                    // Dibujar feedback visual del click (marca en el suelo)
                    if (clickFeedback) {
                        const elapsed = Date.now() - clickFeedback.startTime;
                        const duration = 500; // 0.5 segundos
                        const progress = Math.min(elapsed / duration, 1);
                        const opacity = 1 - progress;

                        if (opacity > 0) {
                            ctx.save();
                            ctx.globalAlpha = opacity;
                            
                            // Dibujar un círculo o 'X' en el destino
                            const size = 15;
                            ctx.strokeStyle = '#4CAF50';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            // Dibujar una 'X'
                            ctx.moveTo(clickFeedback.x - size, clickFeedback.y - size);
                            ctx.lineTo(clickFeedback.x + size, clickFeedback.y + size);
                            ctx.moveTo(clickFeedback.x + size, clickFeedback.y - size);
                            ctx.lineTo(clickFeedback.x - size, clickFeedback.y + size);
                            ctx.stroke();
                            
                            // Dibujar un círculo alrededor
                            ctx.beginPath();
                            ctx.arc(clickFeedback.x, clickFeedback.y, size * 1.2, 0, Math.PI * 2);
                            ctx.stroke();
                            
                            ctx.restore();
                        }
                    }

                    // Restaurar estado del contexto (después de dibujar todo el mundo)
                    ctx.restore();

                    // Siguiente frame
                    animationFrameRef.current = requestAnimationFrame(gameLoop);
                };

                gameLoop();

                return () => {
                    window.removeEventListener('resize', resizeCanvas);
                    if (animationFrameRef.current) {
                        cancelAnimationFrame(animationFrameRef.current);
                    }
                };
            }, [player, otherPlayers, interactiveObjects, nearbyObject, activeMessages, playerData.userId, furniture, camera, clickFeedback, semillaImg, backgroundImg, drawTintedPlayer]);

            return (
                <div className="game-container">
                    <canvas ref={canvasRef}></canvas>
                    {nearbyObject && (
                        <div className="interaction-hint">
                            Presiona E para interactuar
                        </div>
                    )}
                    <div className="ui-overlay">
                        <div>Posición: ({Math.round(player.x)}, {Math.round(player.y)})</div>
                        <div>Jugadores: {Object.keys(otherPlayers).length + 1}</div>
                        {nearbyObject && (
                            <div style={{ marginTop: '8px', color: '#4CAF50' }}>
                                Cerca de: {nearbyObject.type}
                            </div>
                        )}
                        {isAdmin && (
                            <div style={{ marginTop: '8px', color: '#22c55e', fontWeight: 'bold' }}>
                                ⚡ Modo Admin Activo
                            </div>
                        )}
                    </div>
                    <div className="players-list">
                        <h3>En línea ({onlineUsers.length})</h3>
                        {onlineUsers.map(user => (
                            <div key={user.userId} className="player-item">
                                <div
                                    className="player-color-dot"
                                    style={{ backgroundColor: user.color }}
                                />
                                <span>{user.nickname}</span>
                            </div>
                        ))}
                    </div>
                    <div className="controls-hint">
                        <div>Controles: WASD o Flechas del teclado</div>
                        {nearbyObject && (
                            <div style={{ marginTop: '4px' }}>
                                Presiona E para {isAdmin ? 'editar' : 'leer'}
                            </div>
                        )}
                    </div>
                    {selectedObject && (() => {
                        // Buscar el objeto actualizado en la lista para tener siempre la versión más reciente
                        const currentObject = interactiveObjects.find(obj => obj.id === selectedObject.id) || selectedObject;
                        return (
                            <ObjectModal
                                object={currentObject}
                                onClose={() => setSelectedObject(null)}
                                isAdmin={isAdmin}
                                onSave={onSaveObject}
                            />
                        );
                    })()}
                    <ReactionsBar 
                        onSendMessage={handleSendMessage}
                        cooldownActive={cooldownActive}
                    />
                </div>
            );
        };

        // Componente principal App
        const App = () => {
            const [playerData, setPlayerData] = useState(null);
            const [interactiveObjects, setInteractiveObjects] = useState([]);
            const [loading, setLoading] = useState(true);
            const [isAdmin, setIsAdmin] = useState(false);
            const channelRef = useRef(null);
            const [isMobile, setIsMobile] = useState(false);

            // Verificar si es móvil
            useEffect(() => {
                const checkMobile = () => {
                    if (typeof window !== 'undefined') {
                        setIsMobile(window.innerWidth < 768);
                    }
                };

                checkMobile();
                window.addEventListener('resize', checkMobile);

                return () => {
                    window.removeEventListener('resize', checkMobile);
                };
            }, []);

            // Verificar sesión de admin al cargar
            useEffect(() => {
                const checkSession = async () => {
                    const { data: { session } } = await supabase.auth.getSession();
                    if (session) {
                        setIsAdmin(true);
                    }

                    // Escuchar cambios en la autenticación
                    supabase.auth.onAuthStateChange((event, session) => {
                        setIsAdmin(!!session);
                    });
                };

                checkSession();
            }, []);

            // Fetch de objetos interactivos desde Supabase
            useEffect(() => {
                const fetchInteractiveObjects = async () => {
                    try {
                        const { data, error } = await supabase
                            .from('interactive_objects')
                            .select('*')
                            .order('created_at', { ascending: true });

                        if (error) {
                            console.error('Error fetching interactive objects:', error);
                        } else {
                            setInteractiveObjects(data || []);
                        }
                    } catch (err) {
                        console.error('Error:', err);
                    } finally {
                        setLoading(false);
                    }
                };

                fetchInteractiveObjects();
            }, []);

            // Suscribirse a cambios en tiempo real de interactive_objects
            useEffect(() => {
                // Limpiar suscripción anterior si existe
                if (channelRef.current) {
                    supabase.removeChannel(channelRef.current);
                }

                // Crear canal para cambios de la tabla
                const channel = supabase
                    .channel('interactive_objects_changes')
                    .on(
                        'postgres_changes',
                        {
                            event: 'UPDATE',
                            schema: 'public',
                            table: 'interactive_objects'
                        },
                        (payload) => {
                            console.log('Cambio detectado en objeto:', payload);
                            // Actualizar el objeto específico en el estado
                            setInteractiveObjects(prev => 
                                prev.map(obj => 
                                    obj.id === payload.new.id 
                                        ? { ...obj, ...payload.new }
                                        : obj
                                )
                            );
                        }
                    )
                    .on(
                        'postgres_changes',
                        {
                            event: 'INSERT',
                            schema: 'public',
                            table: 'interactive_objects'
                        },
                        (payload) => {
                            console.log('Nuevo objeto insertado:', payload);
                            setInteractiveObjects(prev => [...prev, payload.new]);
                        }
                    )
                    .on(
                        'postgres_changes',
                        {
                            event: 'DELETE',
                            schema: 'public',
                            table: 'interactive_objects'
                        },
                        (payload) => {
                            console.log('Objeto eliminado:', payload);
                            setInteractiveObjects(prev => 
                                prev.filter(obj => obj.id !== payload.old.id)
                            );
                        }
                    )
                    .subscribe();

                channelRef.current = channel;

                return () => {
                    if (channelRef.current) {
                        supabase.removeChannel(channelRef.current);
                        channelRef.current = null;
                    }
                };
            }, []);

            // Función para guardar cambios en un objeto
            const handleSaveObject = async (objectId, newContent) => {
                try {
                    const { data, error } = await supabase
                        .from('interactive_objects')
                        .update({ content: newContent })
                        .eq('id', objectId)
                        .select()
                        .single();

                    if (error) {
                        throw error;
                    }

                    // El cambio se propagará automáticamente vía Realtime
                    console.log('Objeto actualizado exitosamente:', data);
                } catch (error) {
                    console.error('Error al actualizar objeto:', error);
                    throw error;
                }
            };

            const handleLoginSuccess = () => {
                setIsAdmin(true);
            };

            const handleLogout = () => {
                setIsAdmin(false);
            };

            if (isMobile) {
                return (
                    <div className="mobile-restriction active">
                        Esta experiencia está diseñada para ordenadores. Por favor, usa una PC o Notebook.
                    </div>
                );
            }

            if (!playerData) {
                return (
                    <>
                        <AdminLogin 
                            isAdmin={isAdmin} 
                            onLoginSuccess={handleLoginSuccess}
                            onLogout={handleLogout}
                        />
                        <JoinScreen onJoin={setPlayerData} />
                    </>
                );
            }

            if (loading) {
                return (
                    <>
                        <AdminLogin 
                            isAdmin={isAdmin} 
                            onLoginSuccess={handleLoginSuccess}
                            onLogout={handleLogout}
                        />
                        <div className="join-screen">
                            <div className="join-form">
                                <h2 style={{ color: 'white', textAlign: 'center' }}>
                                    Cargando objetos...
                                </h2>
                            </div>
                        </div>
                    </>
                );
            }

            return (
                <>
                    <AdminLogin 
                        isAdmin={isAdmin} 
                        onLoginSuccess={handleLoginSuccess}
                        onLogout={handleLogout}
                    />
                    <GameCanvas 
                        playerData={playerData} 
                        interactiveObjects={interactiveObjects}
                        isAdmin={isAdmin}
                        onSaveObject={handleSaveObject}
                    />
                </>
            );
        };

        // Renderizar la aplicación
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
