<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Explorador 3D del Cubo Binomial (a + b)³</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #root {
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // ============================================
        // THREE.JS SCENE COMPONENT
        // ============================================
        function Scene3D({ a, b, explosion, isLegendVisible }) {
            const mountRef = useRef(null);
            const sceneRef = useRef(null);
            const animationFrameRef = useRef(null);
            const isLegendVisibleRef = useRef(isLegendVisible);
            
            // Keep ref in sync with prop
            useEffect(() => {
                isLegendVisibleRef.current = isLegendVisible;
            }, [isLegendVisible]);

            // Calculate piece positions and geometries
            // The cube (a+b)³ is centered in the main viewport
            const pieces = useMemo(() => {
                const total = a + b;
                const halfTotal = total / 2;
                const offset = explosion * 0.8; // Explosion multiplier
                
                // Base positions (when explosion = 0, pieces form perfect cube)
                // Cube a³: bottom-left-back corner
                const a3BaseX = -halfTotal + a/2;
                const a3BaseY = -halfTotal + a/2;
                const a3BaseZ = -halfTotal + a/2;
                
                // Prism a²b along X axis (extends from a³ in +X direction)
                const a2bXBaseX = -halfTotal + a + b/2;
                const a2bXBaseY = -halfTotal + a/2;
                const a2bXBaseZ = -halfTotal + a/2;
                
                // Prism a²b along Y axis (extends from a³ in +Y direction)
                const a2bYBaseX = -halfTotal + a/2;
                const a2bYBaseY = -halfTotal + a + b/2;
                const a2bYBaseZ = -halfTotal + a/2;
                
                // Prism a²b along Z axis (extends from a³ in +Z direction)
                const a2bZBaseX = -halfTotal + a/2;
                const a2bZBaseY = -halfTotal + a/2;
                const a2bZBaseZ = -halfTotal + a + b/2;
                
                // Prism ab² at corner (extends from a²b prisms)
                const ab2XYBaseX = -halfTotal + a + b/2;
                const ab2XYBaseY = -halfTotal + a + b/2;
                const ab2XYBaseZ = -halfTotal + a/2;
                
                const ab2XZBaseX = -halfTotal + a + b/2;
                const ab2XZBaseY = -halfTotal + a/2;
                const ab2XZBaseZ = -halfTotal + a + b/2;
                
                const ab2YZBaseX = -halfTotal + a/2;
                const ab2YZBaseY = -halfTotal + a + b/2;
                const ab2YZBaseZ = -halfTotal + a + b/2;
                
                // Cube b³: top-right-front corner
                const b3BaseX = halfTotal - b/2;
                const b3BaseY = halfTotal - b/2;
                const b3BaseZ = halfTotal - b/2;

                return [
                    // 1 Cube a³
                    {
                        type: 'a³',
                        position: [
                            a3BaseX - (explosion > 0 ? offset * 0.6 : 0),
                            a3BaseY - (explosion > 0 ? offset * 0.6 : 0),
                            a3BaseZ - (explosion > 0 ? offset * 0.6 : 0)
                        ],
                        size: [a, a, a],
                        color: 0x3b82f6 // Blue (Primary)
                    },
                    // 3 Prisms a²b (along X, Y, Z axes)
                    {
                        type: 'a²b',
                        position: [
                            a2bXBaseX + (explosion > 0 ? offset * 0.4 : 0),
                            a2bXBaseY - (explosion > 0 ? offset * 0.3 : 0),
                            a2bXBaseZ - (explosion > 0 ? offset * 0.3 : 0)
                        ],
                        size: [b, a, a],
                        color: 0x8b5cf6 // Purple (Secondary)
                    },
                    {
                        type: 'a²b',
                        position: [
                            a2bYBaseX - (explosion > 0 ? offset * 0.3 : 0),
                            a2bYBaseY + (explosion > 0 ? offset * 0.4 : 0),
                            a2bYBaseZ - (explosion > 0 ? offset * 0.3 : 0)
                        ],
                        size: [a, b, a],
                        color: 0x8b5cf6
                    },
                    {
                        type: 'a²b',
                        position: [
                            a2bZBaseX - (explosion > 0 ? offset * 0.3 : 0),
                            a2bZBaseY - (explosion > 0 ? offset * 0.3 : 0),
                            a2bZBaseZ + (explosion > 0 ? offset * 0.4 : 0)
                        ],
                        size: [a, a, b],
                        color: 0x8b5cf6
                    },
                    // 3 Prisms ab²
                    {
                        type: 'ab²',
                        position: [
                            ab2XYBaseX + (explosion > 0 ? offset * 0.3 : 0),
                            ab2XYBaseY + (explosion > 0 ? offset * 0.3 : 0),
                            ab2XYBaseZ - (explosion > 0 ? offset * 0.2 : 0)
                        ],
                        size: [b, b, a],
                        color: 0x10b981 // Green (Tertiary)
                    },
                    {
                        type: 'ab²',
                        position: [
                            ab2XZBaseX + (explosion > 0 ? offset * 0.3 : 0),
                            ab2XZBaseY - (explosion > 0 ? offset * 0.2 : 0),
                            ab2XZBaseZ + (explosion > 0 ? offset * 0.3 : 0)
                        ],
                        size: [b, a, b],
                        color: 0x10b981
                    },
                    {
                        type: 'ab²',
                        position: [
                            ab2YZBaseX - (explosion > 0 ? offset * 0.2 : 0),
                            ab2YZBaseY + (explosion > 0 ? offset * 0.3 : 0),
                            ab2YZBaseZ + (explosion > 0 ? offset * 0.3 : 0)
                        ],
                        size: [a, b, b],
                        color: 0x10b981
                    },
                    // 1 Cube b³
                    {
                        type: 'b³',
                        position: [
                            b3BaseX + (explosion > 0 ? offset * 0.6 : 0),
                            b3BaseY + (explosion > 0 ? offset * 0.6 : 0),
                            b3BaseZ + (explosion > 0 ? offset * 0.6 : 0)
                        ],
                        size: [b, b, b],
                        color: 0xef4444 // Red (Quaternary)
                    }
                ];
            }, [a, b, explosion]);

            useEffect(() => {
                if (!mountRef.current) return;

                // Viewport configuration
                const viewportMainWidth = 0.75; // 75% for main viewport
                const viewportLegendWidth = 0.25; // 25% for legend viewport
                
                // Main Scene (Interactive)
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x1a1a2e);
                sceneRef.current = scene;

                // Main Camera (Perspective)
                const mainViewportWidth = mountRef.current.clientWidth * viewportMainWidth;
                const camera = new THREE.PerspectiveCamera(
                    75,
                    mainViewportWidth / mountRef.current.clientHeight,
                    0.1,
                    1000
                );
                camera.position.set(8, 8, 8);
                camera.lookAt(0, 0, 0);

                // Legend Scene (Static)
                const legendScene = new THREE.Scene();
                legendScene.background = new THREE.Color(0x151520); // Slightly darker than main scene for visual separation

                // Legend Camera (Orthographic for 2D-like appearance)
                const legendViewportWidth = mountRef.current.clientWidth * viewportLegendWidth;
                // Base ortho size - will be adjusted dynamically based on a + b
                const baseOrthoSize = 8;
                const legendCamera = new THREE.OrthographicCamera(
                    -baseOrthoSize / 2, baseOrthoSize / 2, // left, right (initial)
                    baseOrthoSize / 2, -baseOrthoSize / 2, // top, bottom (initial)
                    0.1,
                    100
                );
                legendCamera.position.set(0, 0, 10);
                legendCamera.lookAt(0, 0, 0);

                // Renderer
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
                renderer.setScissorTest(true); // Enable scissor test for viewports
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                mountRef.current.appendChild(renderer.domElement);

                // Lights for main scene
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                scene.add(directionalLight);

                // Lights for legend scene (optimized for isometric view)
                const legendAmbientLight = new THREE.AmbientLight(0xffffff, 0.5);
                legendScene.add(legendAmbientLight);

                // Directional light from upper corner to highlight 3D faces
                const legendDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
                legendDirectionalLight.position.set(8, 10, 8);
                legendDirectionalLight.castShadow = false; // Disable shadows for legend
                legendScene.add(legendDirectionalLight);

                // Grid helper (main scene only)
                const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
                scene.add(gridHelper);

                // Axes helper (main scene only)
                const axesHelper = new THREE.AxesHelper(5);
                scene.add(axesHelper);

                // OrbitControls (restricted to main viewport)
                const controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.autoRotate = true;
                controls.autoRotateSpeed = 1.0;
                controls.minDistance = 5;
                controls.maxDistance = 20;
                
                // Restrict controls to main viewport
                controls.addEventListener('start', () => {
                    controls.enabled = true;
                });
                
                // Mouse event handler to restrict controls
                const onMouseMove = (event) => {
                    const legendVisible = isLegendVisibleRef.current;
                    const rect = mountRef.current.getBoundingClientRect();
                    const mouseX = event.clientX - rect.left;
                    const relativeX = mouseX / mountRef.current.clientWidth;
                    // If legend is hidden, controls work everywhere. Otherwise, restrict to main viewport
                    controls.enabled = !legendVisible || relativeX < viewportMainWidth;
                };
                window.addEventListener('mousemove', onMouseMove);

                // Create pieces
                const pieceMeshes = [];
                const legendMeshes = [];
                
                const createPiece = (piece, targetScene) => {
                    const geometry = new THREE.BoxGeometry(...piece.size);
                    const material = new THREE.MeshStandardMaterial({
                        color: piece.color,
                        transparent: true,
                        opacity: 0.85,
                        metalness: 0.3,
                        roughness: 0.7
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(...piece.position);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    
                    // Apply rotation if specified (for normalized legend pieces)
                    if (piece.rotation) {
                        mesh.rotation.set(...piece.rotation);
                    }
                    
                    targetScene.add(mesh);

                    // Add edges
                    const edges = new THREE.EdgesGeometry(geometry);
                    const line = new THREE.LineSegments(
                        edges,
                        new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 })
                    );
                    line.position.set(...piece.position);
                    if (piece.rotation) {
                        line.rotation.set(...piece.rotation);
                    }
                    targetScene.add(line);

                    return { mesh, line, piece };
                };

                // Calculate normalized decomposed pieces for legend (vertical layout with isometric rotation)
                const calculateLegendPieces = () => {
                    // Isometric rotation angles (corrected for better 3D view)
                    const ISO_ROT_X = Math.PI / 5; // ~36 degrees (less vertical, more balanced)
                    const ISO_ROT_Y = Math.PI / 4; // 45 degrees
                    
                    const pieceScale = 0.4; // Scale factor for legend pieces
                    
                    // Calculate dynamic spacing unit based on maximum possible piece size
                    // This ensures pieces never overlap, even at maximum slider values
                    const maxPossibleSize = Math.max(5.0, Math.max(a, b)); // Max slider value is 5.0
                    const spacingUnit = maxPossibleSize * 1.5; // Dynamic spacing multiplier
                    
                    // Horizontal spacing between 3 pieces in same group
                    const maxPieceWidth = Math.max(a, b) * pieceScale;
                    const horizontalSpacing = maxPieceWidth * 3.0; // Generous horizontal spacing
                    
                    // Vertical spacing between groups (dynamic, based on piece sizes)
                    // Account for isometric rotation which increases visible height
                    const maxPieceHeight = Math.max(a, b) * pieceScale;
                    const verticalSpacing = spacingUnit * 1.2; // Large vertical gap between groups
                    
                    // Starting position: distribute groups from top to bottom
                    // Use negative Y values going down (standard in 3D)
                    const topY = spacingUnit * 2.5; // Start high enough from origin
                    const pieces = [];
                    
                    // Grupo 1: Cubo a³ (1 pieza, centered)
                    pieces.push({
                        type: 'a³',
                        position: [0, topY, 0],
                        size: [a * pieceScale, a * pieceScale, a * pieceScale],
                        color: 0x3b82f6, // Blue
                        rotation: [ISO_ROT_X, ISO_ROT_Y, 0] // Isometric rotation
                    });
                    
                    // Grupo 2: Prismas a²b (3 piezas, normalized orientation with isometric rotation)
                    // All three should look identical (same face forward)
                    const a2bSize = [b * pieceScale, a * pieceScale, a * pieceScale];
                    const y2 = topY - verticalSpacing;
                    pieces.push({
                        type: 'a²b',
                        position: [-horizontalSpacing, y2, 0],
                        size: a2bSize,
                        color: 0x8b5cf6, // Purple
                        rotation: [ISO_ROT_X, ISO_ROT_Y, 0] // Isometric rotation - all identical
                    });
                    pieces.push({
                        type: 'a²b',
                        position: [0, y2, 0],
                        size: a2bSize,
                        color: 0x8b5cf6,
                        rotation: [ISO_ROT_X, ISO_ROT_Y, 0] // Isometric rotation - all identical
                    });
                    pieces.push({
                        type: 'a²b',
                        position: [horizontalSpacing, y2, 0],
                        size: a2bSize,
                        color: 0x8b5cf6,
                        rotation: [ISO_ROT_X, ISO_ROT_Y, 0] // Isometric rotation - all identical
                    });
                    
                    // Grupo 3: Prismas ab² (3 piezas, normalized orientation with isometric rotation)
                    const ab2Size = [b * pieceScale, b * pieceScale, a * pieceScale];
                    const y3 = topY - verticalSpacing * 2;
                    pieces.push({
                        type: 'ab²',
                        position: [-horizontalSpacing, y3, 0],
                        size: ab2Size,
                        color: 0x10b981, // Green
                        rotation: [ISO_ROT_X, ISO_ROT_Y, 0] // Isometric rotation
                    });
                    pieces.push({
                        type: 'ab²',
                        position: [0, y3, 0],
                        size: ab2Size,
                        color: 0x10b981,
                        rotation: [ISO_ROT_X, ISO_ROT_Y, 0] // Isometric rotation
                    });
                    pieces.push({
                        type: 'ab²',
                        position: [horizontalSpacing, y3, 0],
                        size: ab2Size,
                        color: 0x10b981,
                        rotation: [ISO_ROT_X, ISO_ROT_Y, 0] // Isometric rotation
                    });
                    
                    // Grupo 4: Cubo b³ (1 pieza, centered)
                    const y4 = topY - verticalSpacing * 3;
                    pieces.push({
                        type: 'b³',
                        position: [0, y4, 0],
                        size: [b * pieceScale, b * pieceScale, b * pieceScale],
                        color: 0xef4444, // Red
                        rotation: [ISO_ROT_X, ISO_ROT_Y, 0] // Isometric rotation
                    });
                    
                    return pieces;
                };

                // Function to create/update legend view
                const updateLegendView = () => {
                    // Remove old legend pieces
                    legendMeshes.forEach(({ mesh, line }) => {
                        legendScene.remove(mesh);
                        legendScene.remove(line);
                        mesh.geometry.dispose();
                        mesh.material.dispose();
                        line.geometry.dispose();
                        line.material.dispose();
                    });
                    legendMeshes.length = 0;

                    // Create new legend pieces
                    const legendPieces = calculateLegendPieces();
                    legendPieces.forEach(piece => {
                        const obj = createPiece(piece, legendScene);
                        legendMeshes.push(obj);
                    });
                };

                // Update function
                const updatePieces = () => {
                    // Remove old main pieces
                    pieceMeshes.forEach(({ mesh, line }) => {
                        scene.remove(mesh);
                        scene.remove(line);
                        mesh.geometry.dispose();
                        mesh.material.dispose();
                        line.geometry.dispose();
                        line.material.dispose();
                    });
                    pieceMeshes.length = 0;

                    // Create new main pieces
                    pieces.forEach(piece => {
                        const obj = createPiece(piece, scene);
                        pieceMeshes.push(obj);
                    });

                    // Update legend view
                    updateLegendView();
                };

                updatePieces();

                // Animation loop with dual viewport rendering
                const animate = () => {
                    animationFrameRef.current = requestAnimationFrame(animate);
                    
                    const width = mountRef.current.clientWidth;
                    const height = mountRef.current.clientHeight;
                    
                    // Dynamic viewport sizing based on legend visibility
                    // Use ref to get current value without re-running useEffect
                    const legendVisible = isLegendVisibleRef.current;
                    let mainWidth, legendWidth, legendX;
                    
                    if (legendVisible) {
                        mainWidth = width * viewportMainWidth;
                        legendWidth = width * viewportLegendWidth;
                        legendX = mainWidth;
                    } else {
                        mainWidth = width; // Full width when legend is hidden
                        legendWidth = 0; // No legend viewport
                        legendX = width;
                    }

                    // Update camera aspect ratio for main viewport
                    camera.aspect = mainWidth / height;
                    camera.updateProjectionMatrix();

                    // Render main viewport (left portion or full width)
                    renderer.setViewport(0, 0, mainWidth, height);
                    renderer.setScissor(0, 0, mainWidth, height);
                    controls.update();
                    renderer.render(scene, camera);

                    // Render legend viewport only if visible
                    if (legendVisible && legendWidth > 0) {
                        // Render vertical divider line (using a thin rectangle as separator)
                        // We'll draw this using the renderer's clear color before rendering legend
                        const originalClearColor = renderer.getClearColor(new THREE.Color());
                        renderer.setViewport(legendX, 0, 1, height);
                        renderer.setScissor(legendX, 0, 1, height);
                        renderer.setClearColor(0x444444); // Divider color
                        renderer.clear();
                        renderer.setClearColor(originalClearColor); // Restore original clear color
                        
                        // Render legend viewport (right 25%)
                        renderer.setViewport(legendX + 1, 0, legendWidth - 1, height);
                        renderer.setScissor(legendX + 1, 0, legendWidth - 1, height);
                    
                        // Calculate exact aspect ratio of legend viewport in pixels
                        const legendAspect = (legendWidth - 1) / height;
                        
                        // Calculate world-space bounds to contain all pieces
                        // Use the same spacing calculation as in calculateLegendPieces
                        const maxPossibleSize = Math.max(5.0, Math.max(a, b));
                        const spacingUnit = maxPossibleSize * 1.5;
                        const pieceScale = 0.4;
                        const maxPieceWidth = Math.max(a, b) * pieceScale;
                        const horizontalSpacing = maxPieceWidth * 3.0;
                        const verticalSpacing = spacingUnit * 1.2;
                        const topY = spacingUnit * 2.5;
                        const bottomY = topY - verticalSpacing * 3;
                        
                        // Calculate required world-space dimensions
                        // Horizontal: 3 pieces side by side with spacing
                        const worldWidth = horizontalSpacing * 2 + maxPieceWidth * 2;
                        // Vertical: from topY to bottomY, plus margins
                        const worldHeight = topY - bottomY + spacingUnit * 1.5; // Add top/bottom margins
                        
                        // CRITICAL: Aspect ratio lock - ensure a 1x1x1 cube appears square
                        // The frustum height and width must respect the viewport aspect ratio
                        // If legendAspect < 1 (viewport is taller than wide), adjust width
                        // If legendAspect > 1 (viewport is wider than tall), adjust height
                        
                        let frustumWidth, frustumHeight;
                        
                        // Calculate base frustum dimensions based on content
                        const contentAspect = worldWidth / worldHeight;
                        
                        if (legendAspect > contentAspect) {
                            // Viewport is wider than content aspect ratio
                            // Adjust width to match viewport aspect
                            frustumHeight = worldHeight;
                            frustumWidth = worldHeight * legendAspect;
                        } else {
                            // Viewport is taller than content aspect ratio
                            // Adjust height to match viewport aspect
                            frustumWidth = worldWidth;
                            frustumHeight = worldWidth / legendAspect;
                        }
                        
                        // Add padding to ensure content doesn't touch edges
                        const paddingFactor = 1.2;
                        frustumWidth *= paddingFactor;
                        frustumHeight *= paddingFactor;
                        
                        // Set frustum bounds (centered at origin)
                        // This ensures a cube 1x1x1 appears perfectly square on screen
                        legendCamera.left = -frustumWidth / 2;
                        legendCamera.right = frustumWidth / 2;
                        legendCamera.top = frustumHeight / 2;
                        legendCamera.bottom = -frustumHeight / 2;
                        legendCamera.updateProjectionMatrix();
                        
                        renderer.render(legendScene, legendCamera);
                    }
                };
                animate();

                // Handle resize
                const handleResize = () => {
                    const width = mountRef.current.clientWidth;
                    const height = mountRef.current.clientHeight;
                    renderer.setSize(width, height);
                    
                    const mainWidth = width * viewportMainWidth;
                    camera.aspect = mainWidth / height;
                    camera.updateProjectionMatrix();
                };
                window.addEventListener('resize', handleResize);

                // Cleanup
                return () => {
                    window.removeEventListener('resize', handleResize);
                    window.removeEventListener('mousemove', onMouseMove);
                    if (animationFrameRef.current) {
                        cancelAnimationFrame(animationFrameRef.current);
                    }
                    pieceMeshes.forEach(({ mesh, line }) => {
                        scene.remove(mesh);
                        scene.remove(line);
                        mesh.geometry.dispose();
                        mesh.material.dispose();
                        line.geometry.dispose();
                        line.material.dispose();
                    });
                    legendMeshes.forEach(({ mesh, line }) => {
                        legendScene.remove(mesh);
                        legendScene.remove(line);
                        mesh.geometry.dispose();
                        mesh.material.dispose();
                        line.geometry.dispose();
                        line.material.dispose();
                    });
                    renderer.dispose();
                    if (mountRef.current && renderer.domElement.parentNode) {
                        mountRef.current.removeChild(renderer.domElement);
                    }
                };
            }, [pieces]);

            return <div ref={mountRef} className="w-full h-full" />;
        }

        // ============================================
        // MAIN APP COMPONENT
        // ============================================
        function App() {
            const [a, setA] = useState(2.0);
            const [b, setB] = useState(1.5);
            const [explosion, setExplosion] = useState(0.0);
            const [isLegendVisible, setIsLegendVisible] = useState(true);

            // Calculate volumes
            const volumes = useMemo(() => {
                const a3 = Math.pow(a, 3);
                const a2b = 3 * Math.pow(a, 2) * b;
                const ab2 = 3 * a * Math.pow(b, 2);
                const b3 = Math.pow(b, 3);
                const total = Math.pow(a + b, 3);

                return { a3, a2b, ab2, b3, total };
            }, [a, b]);

            return (
                <div className="flex h-screen bg-gray-900 text-white">
                    {/* Left Panel - Controls */}
                    <aside className="w-80 bg-gray-800 border-r border-gray-700 p-6 overflow-y-auto">
                        <h1 className="text-2xl font-bold mb-6 text-yellow-400">
                            Cubo Binomial (a + b)³
                        </h1>

                        {/* Formula Display */}
                        <div className="mb-6 p-4 bg-gray-900 rounded-lg border border-gray-700">
                            <div className="text-sm text-gray-300 mb-2">Expansión:</div>
                            <div className="text-lg font-mono text-yellow-400">
                                (a + b)³ = a³ + 3a²b + 3ab² + b³
                            </div>
                        </div>

                        {/* Slider for 'a' */}
                        <div className="mb-6">
                            <label className="block text-sm font-semibold mb-2 text-gray-300">
                                Valor de 'a': <span className="text-yellow-400">{a.toFixed(2)}</span>
                            </label>
                            <input
                                type="range"
                                min="1.0"
                                max="5.0"
                                step="0.1"
                                value={a}
                                onChange={(e) => setA(parseFloat(e.target.value))}
                                className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-yellow-500"
                            />
                            <div className="flex justify-between text-xs text-gray-400 mt-1">
                                <span>1.0</span>
                                <span>5.0</span>
                            </div>
                        </div>

                        {/* Slider for 'b' */}
                        <div className="mb-6">
                            <label className="block text-sm font-semibold mb-2 text-gray-300">
                                Valor de 'b': <span className="text-yellow-400">{b.toFixed(2)}</span>
                            </label>
                            <input
                                type="range"
                                min="1.0"
                                max="5.0"
                                step="0.1"
                                value={b}
                                onChange={(e) => setB(parseFloat(e.target.value))}
                                className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-yellow-500"
                            />
                            <div className="flex justify-between text-xs text-gray-400 mt-1">
                                <span>1.0</span>
                                <span>5.0</span>
                            </div>
                        </div>

                        {/* Explosion/Decomposition Slider */}
                        <div className="mb-6">
                            <label className="block text-sm font-semibold mb-2 text-gray-300">
                                Explosión/Descomposición: <span className="text-yellow-400">{explosion.toFixed(2)}</span>
                            </label>
                            <input
                                type="range"
                                min="0.0"
                                max="2.0"
                                step="0.1"
                                value={explosion}
                                onChange={(e) => setExplosion(parseFloat(e.target.value))}
                                className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-yellow-500"
                            />
                            <div className="flex justify-between text-xs text-gray-400 mt-1">
                                <span>0.0 (Unido)</span>
                                <span>2.0 (Explotado)</span>
                            </div>
                        </div>

                        {/* Volumes Display */}
                        <div className="mb-6">
                            <h2 className="text-lg font-semibold mb-3 text-yellow-400">Volúmenes de las Piezas</h2>
                            <div className="bg-gray-900 rounded-lg p-4 border border-gray-700 space-y-3">
                                <div className="flex items-center justify-between">
                                    <div className="flex items-center gap-2">
                                        <div className="w-4 h-4 rounded bg-blue-500"></div>
                                        <span className="text-sm text-gray-300">a³</span>
                                    </div>
                                    <span className="text-yellow-400 font-mono font-bold">
                                        {volumes.a3.toFixed(3)}
                                    </span>
                                </div>
                                <div className="flex items-center justify-between">
                                    <div className="flex items-center gap-2">
                                        <div className="w-4 h-4 rounded bg-purple-500"></div>
                                        <span className="text-sm text-gray-300">3a²b</span>
                                    </div>
                                    <span className="text-yellow-400 font-mono font-bold">
                                        {volumes.a2b.toFixed(3)}
                                    </span>
                                </div>
                                <div className="flex items-center justify-between">
                                    <div className="flex items-center gap-2">
                                        <div className="w-4 h-4 rounded bg-green-500"></div>
                                        <span className="text-sm text-gray-300">3ab²</span>
                                    </div>
                                    <span className="text-yellow-400 font-mono font-bold">
                                        {volumes.ab2.toFixed(3)}
                                    </span>
                                </div>
                                <div className="flex items-center justify-between">
                                    <div className="flex items-center gap-2">
                                        <div className="w-4 h-4 rounded bg-red-500"></div>
                                        <span className="text-sm text-gray-300">b³</span>
                                    </div>
                                    <span className="text-yellow-400 font-mono font-bold">
                                        {volumes.b3.toFixed(3)}
                                    </span>
                                </div>
                                <div className="border-t border-gray-700 pt-3 mt-3">
                                    <div className="flex items-center justify-between">
                                        <span className="text-sm font-semibold text-gray-200">Total (a+b)³</span>
                                        <span className="text-yellow-400 font-mono font-bold text-lg">
                                            {volumes.total.toFixed(3)}
                                        </span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        {/* Legend */}
                        <div className="text-xs text-gray-400 space-y-2">
                            <p className="font-semibold text-gray-300 mb-2">Leyenda de Colores:</p>
                            <div className="flex items-center gap-2">
                                <div className="w-3 h-3 rounded bg-blue-500"></div>
                                <span>1 Cubo a³</span>
                            </div>
                            <div className="flex items-center gap-2">
                                <div className="w-3 h-3 rounded bg-purple-500"></div>
                                <span>3 Prismas a²b</span>
                            </div>
                            <div className="flex items-center gap-2">
                                <div className="w-3 h-3 rounded bg-green-500"></div>
                                <span>3 Prismas ab²</span>
                            </div>
                            <div className="flex items-center gap-2">
                                <div className="w-3 h-3 rounded bg-red-500"></div>
                                <span>1 Cubo b³</span>
                            </div>
                        </div>
                    </aside>

                    {/* Right Panel - 3D Scene */}
                    <main className="flex-1 relative">
                        {/* Toggle Button for Legend */}
                        <button
                            id="btn-toggle-legend"
                            onClick={() => setIsLegendVisible(!isLegendVisible)}
                            className="absolute top-4 right-4 z-50 bg-gray-800 hover:bg-gray-700 text-yellow-400 border border-gray-600 rounded-lg px-4 py-2 shadow-lg transition-all duration-200 hover:shadow-xl hover:scale-105 flex items-center gap-2 text-sm font-semibold"
                            title={isLegendVisible ? "Ocultar Leyenda" : "Mostrar Leyenda"}
                        >
                            <span className="text-lg">{isLegendVisible ? '◫' : '≡'}</span>
                            <span>{isLegendVisible ? 'Ocultar' : 'Mostrar'} Leyenda</span>
                        </button>
                        <Scene3D a={a} b={b} explosion={explosion} isLegendVisible={isLegendVisible} />
                    </main>
                </div>
            );
        }

        // Render app
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>

